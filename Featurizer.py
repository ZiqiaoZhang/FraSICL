import torch as t
from TrainingFramework.ChemUtils import *
import random
from Models.CMPNN.CMPNNFeaturizer import *
from torch_geometric.data import Data
from Models.Graphormer import algos

# todo(zqzhang): updated in GBv1
from FragComponents.Utils import *

class BasicFeaturizer(object):
    # Featurizers are modules to generate input Tensors and Label Tensor of a given molecule.
    # For different predictive models, such as GCN, ATFP, FraGAT, CMPNN, the requirement of the input Tensors generated by featurizers are different.
    # So the users should implement and choose proper featurizer for their models.
    def __init__(self):
        super(BasicFeaturizer, self).__init__()

    def featurize(self, item):
        raise NotImplementedError(
            "Molecule Featurizer not implemented.")

class FPFeaturizer(BasicFeaturizer):
    # Featurizer to generate raw fingerprints of a given molecule
    def __init__(self, opt):
        super(FPFeaturizer, self).__init__()
        self.opt = opt
        self.MolFPCalculators = {
            'MorganFP' : MorganFPMolFPCalculator(),
            'RDKFP' : RDKFPMolFPCalculator(),
            'MACCSFP' : MACCSFPMolFPCalculator()
        }
        self.MolFPCalculator = self.MolFPCalculators[self.opt.args['MolFP']]

        # if using Morgan FP, radius and nBits should be set.
        if self.opt.args['MolFP'] == 'MorganFP':
            if 'radius' not in self.opt.args:
                raise KeyError(
                    'radius of the Morgan FP not given.'
                )
            elif 'nBits' not in self.opt.args:
                raise KeyError(
                    'nBits of the Morgan FP not given.'
                )
            else:
                self.FP_opt_array = {
                    'radius': self.opt.args['radius'],
                    'nBits': self.opt.args['nBits']
                }
        else:
            self.FP_opt_array = {}

    def featurize(self, item):
        SMILES = item['SMILES']
        value = item['Value']
        mol = GetMol(SMILES)
        FP = self.MolFPCalculator.CalculateFP(mol, self.FP_opt_array)
        FP = t.Tensor(FP)

        label = self.GetLabelFromValues(value)

        return FP, label

    def GetLabelFromValues(self, values):
        label = []
        if self.opt.args['ClassNum'] == 1:
            if self.opt.args['TaskNum'] == 1:
                label.append(float(values))
            else:
                for v in values:
                    label.append(float(v))
            label = t.Tensor(label)
        else:
            for v in values:
                label.append(int(v))
            label = t.Tensor(label).long()
        label.unsqueeze_(-1)

        return label

class SMILESFeaturizer(BasicFeaturizer):
    def __init__(self, opt):
        super(SMILESFeaturizer, self).__init__()
        self.opt = opt

    def featurize(self, item):
        SMILES = item['SMILES']
        Value = item['Value']
        Label = self.GetLabelFromValues(Value)

        return SMILES, Label

    def GetLabelFromValues(self, values):
        label = []
        if self.opt.args['ClassNum'] == 1:
            if self.opt.args['TaskNum'] == 1:
                label.append(float(values))
            else:
                for v in values:
                    label.append(float(v))
            label = t.Tensor(label)
        else:
            for v in values:
                label.append(int(v))
            label = t.Tensor(label).long()
        label.unsqueeze_(-1)

        return label

class SMILESTokenFeaturizer(BasicFeaturizer):
    def __init__(self, opt):
        super(SMILESTokenFeaturizer, self).__init__()
        self.opt = opt
        self.SMILESdict = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
         '#', '%', '(', ')', '+', '-', '.', '/', '=', '@', '[', '\\', ']',
         'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',
         'V', 'W', 'X', 'Y', 'Z',
         'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
         'v', 'w', 'x', 'y', 'z',
                           'STA', 'END', 'PAD']
        self.MaxDictLength = len(self.SMILESdict)
        opt.set_args('MaxDictLength',self.MaxDictLength)

    def prefeaturize(self, dataset):
        max_len = 0
        for item in dataset:
            # Use canonical SMILES
            SMILES = item['SMILES']
            mol = GetMol(SMILES)
            SMILES = Chem.MolToSmiles(mol)
            item['SMILES'] = SMILES
            cur_len = len(item['SMILES'])
            if cur_len > max_len:
                max_len = cur_len
        self.MaxSMILESLength = max_len

    def featurize(self, item):
        SMILES = item['SMILES']
        Value = item['Value']
        Label = self.GetLabelFromValues(Value)
        # mol = GetMol(SMILES)
        # SMILES = Chem.MolToSmiles(mol)
        TokenVector = self.SMILES2indexvector(SMILES)
        return TokenVector, Label


    def SMILES2indexvector(self, SMILES):
        TokenVector = []
        TokenVector.append(self.token2index('STA'))
        for token in SMILES:
            TokenVector.append(self.token2index(token))
        TokenVector.append(self.token2index('END'))
        while(len(TokenVector) < self.MaxSMILESLength+2):
            TokenVector.append(self.token2index('PAD'))
        assert len(TokenVector) == self.MaxSMILESLength + 2
        TokenVector = t.Tensor(TokenVector).long()
        return TokenVector

    def token2index(self, token):
        loc = self.SMILESdict.index(token)
        return loc

    def token2onehot(self, token):
        vector = t.zeros(self.MaxDictLength)
        loc = self.SMILESdict.index(token)
        vector[loc] = 1
        return vector

    def GetLabelFromValues(self, values):
        label = []
        if self.opt.args['ClassNum'] == 1:
            if self.opt.args['TaskNum'] == 1:
                label.append(float(values))
            else:
                for v in values:
                    label.append(float(v))
            label = t.Tensor(label)
        else:
            for v in values:
                label.append(int(v))
            label = t.Tensor(label).long()
        label.unsqueeze_(-1)

        return label

class GraphFeaturizer(BasicFeaturizer):
    # Featurizer used for naive GCN model to generate AdjMat, FeatureMat and Label
    def __init__(self):
        super(GraphFeaturizer, self).__init__()

    def featurize(self, item):
        SMILES = item['SMILES']
        Value = item['Value']
        mol = GetMol(SMILES)
        AdjMat = GetAdjMat(mol)
        FeatureMat = GetMolFeatureMat(mol)
        AdjMat = t.Tensor(AdjMat)
        FeatureMat = t.Tensor(FeatureMat)
        Label = self.GetLabelFromValues(Value)

        # The naive GCN cannot be used for a graph with isolated nodes
        # Those nodes that are not connected with other nodes should be disgard.
        # This trick may not be correct, it should be checked latter.
        ids = self.zero_degree_check(AdjMat)
        AdjMat = t.index_select(AdjMat, dim=0, index=ids)
        AdjMat = t.index_select(AdjMat, dim=1, index=ids)
        FeatureMat = t.index_select(FeatureMat, dim=0, index=ids)

        return (AdjMat, FeatureMat), Label

    def zero_degree_check(self, AdjMat):
        # to find out that which node is isolated
        # ids is the index of the nodes of which the degree is not zero.
        degree = t.sum(AdjMat, dim=1)
        ids = [i for i,x in enumerate(degree) if x != 0]
        ids = t.Tensor(ids).long()
        return ids

    def GetLabelFromValues(self, values):
        label = []
        if self.opt.args['ClassNum'] == 1:
            if self.opt.args['TaskNum'] == 1:
                label.append(float(values))
            else:
                for v in values:
                    label.append(float(v))
            label = t.Tensor(label)
        else:
            for v in values:
                label.append(int(v))
            label = t.Tensor(label).long()
        label.unsqueeze_(-1)

        return label

class PyGGraphFeaturizer(BasicFeaturizer):
    # Featurizer used for PyGGNNs, to generate a PyG.Data object from a given SMILES item.
    def __init__(self, opt):
        super(PyGGraphFeaturizer, self).__init__()
        self.opt = opt

    def featurize(self, item):
        SMILES = item['SMILES']
        Value = item['Value']
        mol = GetMol(SMILES)
        EdgeList = t.Tensor(GetEdgeList(mol)).long()
        AtomFeatureMat = t.Tensor(GetMolFeatureMat(mol))
        BondFeatureMat = t.Tensor(GetBondFeatureMat(mol))
        Label = self.GetLabelFromValues(Value)
        # print(f"Label.size():{Label.size()}")
        data = Data(x=AtomFeatureMat, edge_index = EdgeList.t().contiguous(), y = Label.t(), edge_attr = BondFeatureMat)
        return data

    def GetLabelFromValues(self, values):
        label = []
        if self.opt.args['ClassNum'] == 1:
            if self.opt.args['TaskNum'] == 1:
                label.append(float(values))
            else:
                for v in values:
                    label.append(float(v))
            label = t.Tensor(label)
        else:
            for v in values:
                label.append(int(v))
            label = t.Tensor(label).long()
        label.unsqueeze_(-1)

        return label

class PyGACGraphFeaturizer(BasicFeaturizer):
    # Featurizer used for PyGGNNs, to generate a PyG.Data object from a given SMILES item.
    def __init__(self, opt):
        super(PyGACGraphFeaturizer, self).__init__()
        self.opt = opt

    def featurize(self, item):
        SMILES1 = item['SMILES1']
        SMILES2 = item['SMILES2']
        Value = item['Value']
        mol1 = GetMol(SMILES1)
        EdgeList1 = t.Tensor(GetEdgeList(mol1, bidirection = True)).long()
        AtomFeatureMat1 = t.Tensor(GetMolFeatureMat(mol1))
        BondFeatureMat1 = t.Tensor(GetBondFeatureMat(mol1, bidirection = True))
        atomnum1 = mol1.GetNumAtoms()

        mol2 = GetMol(SMILES2)
        EdgeList2 = t.Tensor(GetEdgeList(mol2, bidirection = True, offset=atomnum1)).long()
        AtomFeatureMat2 = t.Tensor(GetMolFeatureMat(mol2))
        BondFeatureMat2 = t.Tensor(GetBondFeatureMat(mol2, bidirection = True))
        AtomFeatureMat = t.cat([AtomFeatureMat1, AtomFeatureMat2], dim=0)
        EdgeList = t.cat([EdgeList1, EdgeList2], dim=0)
        BondFeatureMat = t.cat([BondFeatureMat1, BondFeatureMat2], dim=0)
        Label = self.GetLabelFromValues(Value)
        # generate masks
        AtomNum1 = AtomFeatureMat1.size()[0]
        BondNum1 = BondFeatureMat1.size()[0]
        AtomNum2 = AtomFeatureMat2.size()[0]
        BondNum2 = BondFeatureMat2.size()[0]
        # AtomMask1 = t.zeros(AtomNum1).long()
        # AtomMask2 = t.ones(AtomNum2).long()
        # BondMask1 = t.zeros(BondNum1).long()
        # BondMask2 = t.ones(BondNum2).long()
        # AtomMask = t.cat([AtomMask1, AtomMask2])
        # BondMask = t.cat([BondMask1, BondMask2])
        data = Data(x=AtomFeatureMat, edge_index = EdgeList.t().contiguous(), y = Label.t(), edge_attr = BondFeatureMat, atom_num = t.Tensor([AtomNum1, AtomNum2]).long(), bond_num = t.Tensor([BondNum1, BondNum2]).long())#atom_mask = AtomMask, bond_mask = BondMask)
        assert data.is_undirected()
        return data

    def GetLabelFromValues(self, values):
        label = []
        if self.opt.args['ClassNum'] == 1:
            if self.opt.args['TaskNum'] == 1:
                label.append(float(values))
            else:
                for v in values:
                    label.append(float(v))
            label = t.Tensor(label)
        else:
            for v in values:
                label.append(int(v))
            label = t.Tensor(label).long()
        label.unsqueeze_(-1)

        return label

class PyGFragGraphFeaturizer(BasicFeaturizer):
    # Featurizer used for PyGGNNs, cutting meaningful subgraph, to generate a PyG. Data object from a given SMILES item.
    def __init__(self, opt):
        super(PyGFragGraphFeaturizer, self).__init__()
        self.opt = opt
        self.flag = True

    def featurize(self, item):
        SMILES = item['SMILES']
        Value = item['Value']
        mol = GetMol(SMILES)
        Adj = GetAdjMat(mol)
        EdgeList = t.Tensor(GetEdgeList(mol, bidirection=True)).long()
        # print(EdgeList)
        # print(EdgeList.size()) [num_edges, 2]
        AtomFeatureMat = t.Tensor(GetMolFeatureMat(mol))
        BondFeatureMat = t.Tensor(GetBondFeatureMat(mol, bidirection=True))
        Label = self.GetLabelFromValues(Value)
        # cut SingleBond
        if self.opt.args['CutMethod'] == 'CC':
            SingleBond_List = t.Tensor(GetCCSingleBonds(mol)).long()
        elif self.opt.args['CutMethod'] == 'CX':
            SingleBond_List = t.Tensor(GetCXSingleBonds(mol)).long()
        else:
            SingleBond_List = t.Tensor(GetSingleBonds(mol)).long()
        # update edge_index, edge_attr(GINE) 暂不考虑
        # data = Data(x=AtomFeatureMat, edge_index = EdgeList.t().contiguous(), y = Label, edge_attr = BondFeatureMat)
        # print(data)
        Atom_Num = AtomFeatureMat.size()[0]
        # judge whether the input graph is connected or not.
        Adj = t.Tensor(Adj).long()
        seen_node= self.SearchConnectedComponent(Adj,0)
        if len(seen_node) != Atom_Num:
            self.flag = False
        else:
            self.flag = True

        Adj = np.array(Adj)
        EdgeList, Adj = self.GetFragments(SingleBond_List, EdgeList, Adj)
        Adj = t.Tensor(Adj).long()
        # print(Adj)
        # print(Frag_Num)
        # check whether Adj is symmetric or not.
        square_atoms = Atom_Num * Atom_Num
        if t.sum(Adj.t() == Adj).item() != square_atoms:
            raise ValueError
        else:
            pass
        # search connected component，also means meaningful subgraphs
        seen = set()
        frag_node_list = []
        for node in range(Adj.size()[0]):
            if node not in seen:
                node_set = self.SearchConnectedComponent(Adj, node)
                # print(node_set)
                frag_node_list.append(list(node_set))
                # subgraph = data.subgraph(t.Tensor(list(node_set)).long())
                seen.update(node_set)
        Frag_Num = len(frag_node_list)
        # print(frag_node_list)
        JT_EdgeList = self.CreateJunctionTree(SingleBond_List, frag_node_list)
        JT_BondNum = JT_EdgeList.size()[1]/2
        # print(JT_EdgeList)
        data = Data(x=AtomFeatureMat, edge_index = EdgeList.t().contiguous(), y = Label.t(), edge_attr = BondFeatureMat,
                    JT_edge_index = JT_EdgeList, atom_num = t.Tensor([Atom_Num]).long(), JT_bond_num = t.Tensor([JT_BondNum]).long(),
                    frag_num = t.Tensor([Frag_Num]).long(), frag_node_set = frag_node_list)
        #
        # print(data.JT_edge_index)
        assert data.is_undirected()
        return data

    def SearchConnectedComponent(self, adj, source):
        #BFS
        queue = []
        seen = set()
        seen.add(source)
        queue.insert(0, source)
        while len(queue) > 0:
            this_node = queue.pop(0)
            for i in range(adj.shape[0]):
                if (adj[this_node][i] == 1) & (i not in seen):
                    seen.add(i)
                    queue.append(i)
        return seen

    def GetFragments(self, singlebondlist, edge_list, adj):
        if min(edge_list.shape) != 0:
            if len(singlebondlist) > 0:
                # remove the correlative edge_index of SingleBond from EdgeList
                singlebond_list = singlebondlist[:, 1:].tolist()
                # print(singlebond_list)
                # update edge_index and adj
                while(len(singlebond_list)):
                    #find the index of SingleBond in EdgeList
                    assert singlebond_list[0] in edge_list.tolist()
                    edge_list_idx = edge_list.tolist().index(singlebond_list[0])
                    edge_list = edge_list[t.arange(edge_list.size(0))!=edge_list_idx]
                    adj[singlebond_list[0][0],singlebond_list[0][1]] = 0
                    #bidirection
                    clone_bond = [singlebond_list[0][1], singlebond_list[0][0]]
                    # print(clone_bond)
                    assert clone_bond in edge_list.tolist()
                    edge_list_idx = edge_list.tolist().index(clone_bond)
                    edge_list = edge_list[t.arange(edge_list.size(0))!=edge_list_idx]
                    adj[clone_bond[0],clone_bond[1]] = 0
                    singlebond_list.pop(0)
                    # print(adj)
                assert len(singlebond_list) == 0
            else:
                pass
        else:
            pass
        return edge_list, adj

    def CreateJunctionTree(self, singlebondlist, frag_node_list):
        # JT_edge_index
        if len(singlebondlist) > 0:
            singlebondlist = singlebondlist[:, 1:].tolist()
            JT_EdgeList = []
            for singlebond in singlebondlist:
                begin_atom = singlebond[0]
                end_atom = singlebond[1]
                begin_frag_idx = -1
                end_frag_idx = -1
                for node_list in frag_node_list:
                    if begin_atom in node_list:
                        begin_frag_idx = frag_node_list.index(node_list)

                    #list tmp_set 存放孤点
                    elif end_atom in node_list:
                        end_frag_idx = frag_node_list.index(node_list)

                    if (begin_frag_idx != -1) & (end_frag_idx != -1):
                        if begin_frag_idx > end_frag_idx:
                            tmp = begin_frag_idx
                            begin_frag_idx = end_frag_idx
                            end_frag_idx = tmp
                            edge = [end_frag_idx, begin_frag_idx]
                            clone_edge = [begin_frag_idx, end_frag_idx]
                        else:
                            edge = [begin_frag_idx, end_frag_idx]
                            clone_edge = [end_frag_idx, begin_frag_idx]
                assert begin_frag_idx != -1
                assert end_frag_idx != -1
                assert begin_frag_idx < end_frag_idx
                JT_EdgeList.append(edge)
                JT_EdgeList.append(clone_edge)
            JT_EdgeList =  t.Tensor(JT_EdgeList).long()
            JT_EdgeList = JT_EdgeList.t().contiguous()
        else:
            # only one subgraph(self), no singlebond need to cut
            JT_EdgeList = np.empty((2, 0), dtype = np.int64)
            JT_EdgeList = t.Tensor(JT_EdgeList).long().contiguous()
        return JT_EdgeList

    def GetLabelFromValues(self, values):
            label = []
            if self.opt.args['ClassNum'] == 1:
                if self.opt.args['TaskNum'] == 1:
                    label.append(float(values))
                else:
                    for v in values:
                        label.append(float(v))
                label = t.Tensor(label)
            else:
                for v in values:
                    label.append(int(v))
                label = t.Tensor(label).long()
            label.unsqueeze_(-1)

            return label

# todo(zqzhang): updated in TPv8
class PPyGFraGATFeaturizer(BasicFeaturizer):
    def __init__(self, opt, mode):
        super(PPyGFraGATFeaturizer, self).__init__()
        self.opt = opt
        self.mode = mode

    def featurize(self, item):
        SMILES = item['SMILES']
        mol = GetMol(SMILES)
        Value = item['Value']
        Label = self.GetLabelFromValues(Value)
        if self.opt.args['FeatureCategory'] == 'BaseOH':
            x, edge_attr = GetBaseFeatureOH(mol)
        elif self.opt.args['FeatureCategory'] == 'BaseED':
            x, edge_attr = GetBaseFeatureED(mol)
        elif self.opt.args['FeatureCategory'] == 'OGB':
            x, edge_attr = GetOGBFeature(mol)
        elif self.opt.args['FeatureCategory'] == 'RichOH':
            x, edge_attr = GetRichFeatureOH(mol)
        elif self.opt.args['FeatureCategory'] == 'RichED':
            x, edge_attr = GetRichFeatureED(mol)
        else:
            raise NotImplementedError('No feature category.')

        x_orimol = t.Tensor(x)

        edge_attr_orimol = t.Tensor(edge_attr).long()
        edge_index_orimol = t.Tensor(GetEdgeList(mol, bidirection = True)).long().t()


        total_atom_num = x_orimol.size()[0]
        total_bond_num = edge_attr_orimol.size()[0]     # total_bond_num is the edge_num, which is directional
        SingleBondList = GetSingleBonds(mol)
        singlebond_num = len(SingleBondList)
        if singlebond_num == 0:
            singlebonds = (t.ones([1, 3]) * -1).long()
        else:
            singlebonds = t.Tensor(SingleBondList).long()
        # SingleBonds = t.Tensor(SingleBondList).long()
        # mask_len = self.max_singlebond_num - singlebond_num + 1
        # mask = t.ones([mask_len, 3]) * -1
        # singlebonds_masked = t.cat([SingleBonds, mask], dim=0)

        # data = Data(x = x_orimol,
        #             edge_attr = edge_attr_orimol,
        #             edge_index = edge_index_orimol,
        #             y = Label.t(),
        #             singlebonds = singlebonds,
        #             atom_num = total_atom_num,
        #             bond_num = total_bond_num,
        #             singlebond_num = singlebond_num
        #             )

        # return data



        mask_orimol = t.zeros([1,total_atom_num]).long()

        if self.mode == 'TRAIN':
            # cut one bond
            edge_index_frags, edge_attr_frags, bond_idx, [start_atom, end_atom] = self.CutOneSingleBond(mol, edge_index_orimol, edge_attr_orimol)

            if bond_idx != None:
                X_12, Attr_12, Index_12, Mask_12 = self.CatGraphs(x_orimol, x_orimol, edge_attr_orimol, edge_attr_frags, edge_index_orimol, edge_index_frags)
                mask1, mask2 = self.GetComponentMasks(start_atom,end_atom,total_atom_num,edge_index_frags)
                mask_cur = self.MergeMask(mask_orimol, mask1, mask2)
                # print(mask_cur)

                edge_attr_JT, edge_index_JT = self.CreateJunctionTree(edge_attr_orimol,bond_idx)
                x_JT = t.zeros([2, x_orimol.size()[1]])
                # print(edge_attr_JT)
                X_123, Attr_123, Index_123, Mask_tmp = self.CatGraphs(X_12, x_JT, Attr_12, edge_attr_JT, Index_12, edge_index_JT)

                cur_graph_num = mask_cur.max()
                mask_cur = t.cat([mask_cur, t.ones([1,2])*(cur_graph_num+1)],dim=1)

            else:
                X_12, Attr_12, Index_12, Mask_12 = self.CatGraphs(x_orimol, x_orimol, edge_attr_orimol, edge_attr_orimol, edge_index_orimol, edge_index_orimol)
                mask1, mask2 = self.GetComponentMasks(None, None, total_atom_num, edge_index_orimol)
                mask_cur = self.MergeMask(mask_orimol, mask1, mask2)

                edge_attr_JT,edge_index_JT = self.CreateJunctionTree(edge_attr_orimol,bond_idx)
                x_JT = t.zeros([2, x_orimol.size()[1]])
                X_123, Attr_123, Index_123, Mask_tmp = self.CatGraphs(X_12, x_JT, Attr_12, edge_attr_JT, Index_12, edge_index_JT)

                cur_graph_num = mask_cur.max()
                mask_cur = t.cat([mask_cur, t.ones([1, 2]) * (cur_graph_num + 1)], dim = 1)

            pad_mask = self.PadMask(mask_cur)
            data = Data(x = X_123,
                        edge_index = Index_123,
                        y = Label.t(),
                        edge_attr = Attr_123,
                        masks = pad_mask,
                        atom_num = t.Tensor([total_atom_num]))
                        # edge_index_changed = edge_index_changed,
                        # edge_attr_JT = edge_attr_JT,
                        # edge_index_JT = edge_index_JT)
                        # masks = [mask1, mask2])
            return data

        elif self.mode == 'EVAL':
            AllFragmentEdgeIndex, AllFragmentAttr, AllCutBondIdx, AllCutBondVertex = self.CutAllSingleBonds(mol, edge_index_orimol, edge_attr_orimol)

            if len(AllCutBondIdx) != 0:
                # AllJTEdgeAttr = []
                # AllJTEdgeIndex = []
                # AllMasks = []

                X_cur = x_orimol
                Attr_cur = edge_attr_orimol
                Index_cur = edge_index_orimol
                mask_cur = mask_orimol
                for i in range(len(AllCutBondIdx)):
                    edge_attr_frags = AllFragmentAttr[i]
                    edge_index_frags = AllFragmentEdgeIndex[i]
                    X_cur, Attr_cur, Index_cur, Mask_cur = self.CatGraphs(X_cur, x_orimol, Attr_cur, edge_attr_frags, Index_cur, edge_index_frags)
                    bond_idx = AllCutBondIdx[i]
                    (start_atom, end_atom) = AllCutBondVertex[i]
                    mask1, mask2 = self.GetComponentMasks(start_atom, end_atom, total_atom_num, edge_index_frags)
                    mask_cur = self.MergeMask(mask_cur, mask1, mask2)

                    edge_attr_JT, edge_index_JT = self.CreateJunctionTree(edge_attr_orimol, bond_idx)
                    x_JT = t.zeros([2, x_orimol.size()[1]])
                    X_cur, Attr_cur, Index_cur, Mask_cur = self.CatGraphs(X_cur, x_JT, Attr_cur, edge_attr_JT, Index_cur, edge_index_JT)

                    cur_graph_num = mask_cur.max()
                    mask_cur = t.cat([mask_cur, t.ones([1,2])*(cur_graph_num+1)], dim=1)

            else:
                X_12, Attr_12, Index_12, Mask_12 = self.CatGraphs(x_orimol, x_orimol, edge_attr_orimol,
                                                                  edge_attr_orimol, edge_index_orimol,
                                                                  edge_index_orimol)
                mask1, mask2 = self.GetComponentMasks(None, None, total_atom_num, edge_index_orimol)
                mask_cur = self.MergeMask(mask_orimol, mask1, mask2)

                edge_attr_JT, edge_index_JT = self.CreateJunctionTree(edge_attr_orimol, None)
                x_JT = t.zeros([2, x_orimol.size()[1]])
                X_cur, Attr_cur, Index_cur, Mask_tmp = self.CatGraphs(X_12, x_JT, Attr_12, edge_attr_JT, Index_12,
                                                                      edge_index_JT)

                cur_graph_num = mask_cur.max()
                mask_cur = t.cat([mask_cur, t.ones([1, 2]) * (cur_graph_num + 1)], dim = 1)
                # print(f'mask_cur: {mask_cur}')

            pad_mask = self.PadMask(mask_cur)
            data = Data(x = X_cur,
                        edge_index = Index_cur,
                        y = Label.t(),
                        edge_attr = Attr_cur,
                        masks = pad_mask,
                        atom_num = t.Tensor([total_atom_num]))

            return data


        else:
            raise KeyError("Invalid featurizer mode given.")

    def GetLabelFromValues(self, values):
        label = []
        if self.opt.args['ClassNum'] == 1:
            if self.opt.args['TaskNum'] == 1:
                label.append(float(values))
            else:
                for v in values:
                    label.append(float(v))
            label = t.Tensor(label)
        else:
            for v in values:
                label.append(int(v))
            label = t.Tensor(label).long()
        label.unsqueeze_(-1)

        return label

    def CutOneSingleBond(self, mol, edge_index_origin, edge_attr_origin):
        edge_index = edge_index_origin.t().tolist()
        edge_attr = edge_attr_origin.clone()
        edge_num = len(edge_index)
        SingleBondList = GetSingleBonds(mol)
        if len(SingleBondList) > 0:
            # choose one bond to cut
            print(f"randomly chosen one bond from {len(SingleBondList)} breakable bonds")
            random.shuffle(SingleBondList)
            [bond_idx, start_atom_idx, end_atom_idx] = SingleBondList[0]
            assert [start_atom_idx, end_atom_idx] in edge_index
            assert [end_atom_idx, start_atom_idx] in edge_index
            # check the location of the chosen bond
            bond_idx_directed = [2 * bond_idx, 2 * bond_idx + 1]
            # print(f"bond_index_directed[0]: {bond_idx_directed[0]}")
            # print(f"edge_index: {edge_index}")
            # print(f"bond: {start_atom_idx, end_atom_idx}")
            assert edge_index[bond_idx_directed[0]] == [start_atom_idx, end_atom_idx]
            assert edge_index[bond_idx_directed[1]] == [end_atom_idx, start_atom_idx]
            # remove bonds in edge_index
            edge_index.remove([start_atom_idx, end_atom_idx])
            edge_index.remove([end_atom_idx, start_atom_idx])
            assert len(edge_index) == edge_num - 2
            edge_index = t.Tensor(edge_index).long().t()
            # remove bond attr in edge_attr
            edge_attr = self.DeleteTensorRow(edge_attr, bond_idx_directed[0])
            edge_attr = self.DeleteTensorRow(edge_attr, bond_idx_directed[0])
            assert edge_attr.size()[0] == edge_index.size()[1]
            assert False not in (edge_attr[bond_idx_directed[0]] == edge_attr_origin[2*(bond_idx+1)])

            return edge_index, edge_attr, bond_idx, [start_atom_idx, end_atom_idx]

        else:
            return edge_index_origin, edge_attr_origin, None, [None, None]

    def CutAllSingleBonds(self, mol, edge_index_origin, edge_attr_origin):
        edge_index = edge_index_origin.t().tolist()
        edge_attr = edge_attr_origin.clone()
        edge_num = len(edge_index)
        SingleBondList = GetSingleBonds(mol)
        AllFragmentEdgeIndex = []
        AllFragmentAttr = []
        AllBondIdx = []
        AllBondVertex = []
        if len(SingleBondList) > 0:
            for item in SingleBondList:
                (bond_idx, start_atom_idx, end_atom_idx) = item
                AllBondIdx.append(bond_idx)
                edge_index_tmp = edge_index.copy()
                edge_attr_tmp = edge_attr.clone()
                assert [start_atom_idx, end_atom_idx] in edge_index_tmp
                assert [end_atom_idx, start_atom_idx] in edge_index_tmp
                AllBondVertex.append([start_atom_idx, end_atom_idx])

                bond_idx_directed = [2 * bond_idx, 2 * bond_idx + 1]
                # print(f"bond_index_directed[0]: {bond_idx_directed[0]}")
                # print(f"edge_index: {edge_index}")
                # print(f"bond: {start_atom_idx, end_atom_idx}")
                assert edge_index_tmp[bond_idx_directed[0]] == [start_atom_idx, end_atom_idx]
                assert edge_index_tmp[bond_idx_directed[1]] == [end_atom_idx, start_atom_idx]

                edge_index_tmp.remove([start_atom_idx, end_atom_idx])
                edge_index_tmp.remove([end_atom_idx, start_atom_idx])
                assert len(edge_index_tmp) == edge_num - 2
                edge_index_tmp = t.Tensor(edge_index_tmp).long().t()
                AllFragmentEdgeIndex.append(edge_index_tmp)
                edge_attr_tmp = self.DeleteTensorRow(edge_attr_tmp, bond_idx_directed[0])
                edge_attr_tmp = self.DeleteTensorRow(edge_attr_tmp, bond_idx_directed[0])
                assert edge_attr_tmp.size()[0] == edge_index_tmp.size()[1]
                assert False not in (edge_attr_tmp[bond_idx_directed[0]] == edge_attr_origin[2 * (bond_idx + 1)])
                AllFragmentAttr.append(edge_attr_tmp)

            return AllFragmentEdgeIndex, AllFragmentAttr, AllBondIdx, AllBondVertex
        else:
            return [edge_index_origin], [edge_attr_origin], AllBondIdx, AllBondVertex

    def CreateJunctionTree(self, edge_attr, bond_idx):
        if bond_idx == None:
            bond_feat_len = edge_attr.size()[1]
            edge_attr_JT = t.Tensor(np.empty([0,bond_feat_len]))
            edge_index_JT = t.Tensor(np.empty((2,0), dtype = np.int64)).long()
        else:
            cut_bond_attr = edge_attr[(bond_idx*2)].unsqueeze(0)
            # print(f"cut_bond_attr size :{cut_bond_attr.size()}")
            edge_attr_JT = t.cat([cut_bond_attr, cut_bond_attr],dim=0)
            # print(f"edge_attr_JT size: {edge_attr_JT.size()}")
            edge_index_JT = t.Tensor([[0,1],[1,0]]).long()

        return edge_attr_JT, edge_index_JT

    def ComponentSearch(self, total_atom_num, edge_index, root_node):
        candidate_set = []
        candidate_set.append(root_node)
        mask = np.zeros([total_atom_num])
        mask[root_node] = 1

        while len(candidate_set) > 0:
            node = candidate_set[0]
            candidate_set.pop(0)

            for i in range(len(edge_index[0])):
                if edge_index[0][i] == node:
                    neighbor = edge_index[1][i]
                    if mask[neighbor] == 0:
                        candidate_set.append(neighbor)
                        mask[neighbor] = 1

        return t.Tensor(mask).long()

    def GetComponentMasks(self, root_node1, root_node2, total_atom_num, edge_index):
        if (root_node1 == None) and (root_node2 == None):
            mask1 = t.Tensor(np.ones([total_atom_num]))
            mask2 = t.Tensor(np.zeros([total_atom_num]))
        else:
            mask1 = self.ComponentSearch(total_atom_num, edge_index, root_node1)
            mask2 = self.ComponentSearch(total_atom_num, edge_index, root_node2)

        return mask1, mask2

    def CatGraphs(self, X1, X2, attr1, attr2, index1, index2):
        graph1_size = X1.size()[0]
        graph2_size = X2.size()[0]
        graph1_bondnum = attr1.size()[0]
        graph2_bondnum = attr2.size()[0]
        assert index1.size()[1] == graph1_bondnum
        assert index2.size()[1] == graph2_bondnum

        # cat Tensors
        X_all = t.cat([X1, X2],dim=0)
        Attr_all = t.cat([attr1, attr2],dim=0)

        index2 = index2 + graph1_size
        Index_all = t.cat([index1, index2],dim=1).long()

        # check
        assert Attr_all.size()[0] == Index_all.size()[1]
        assert Index_all[0].max() < X_all.size()[0]
        assert Index_all[1].max() < X_all.size()[0]
        chosen_bond = int(random.random() * Index_all.size()[1])
        # print(f'Chosen_bond: {chosen_bond}')
        chosen_bond_attr = Attr_all[chosen_bond]
        # print(f'Chosen_bond_attr: {chosen_bond_attr}')

        if chosen_bond < graph1_bondnum:
            assert False not in (chosen_bond_attr == attr1[chosen_bond])
        else:
            assert False not in (chosen_bond_attr == attr2[chosen_bond-graph1_bondnum])


        # Generate Mask
        mask1 = t.zeros([1,graph1_size])
        mask2 = t.ones([1,graph2_size])
        mask = t.cat([mask1, mask2],dim=1).long()
        assert mask.size()[1] == X_all.size()[0]

        return X_all, Attr_all, Index_all, mask

    def DeleteTensorRow(self, tensor, index, dim=0):
        if dim==0:
            t1 = tensor[0:index, :]
            t2 = tensor[index+1:,:]
            return t.cat([t1,t2],dim=0)

    def MergeMask(self, mask_cur, mask1, mask2):
        # print(mask1)
        # print(mask2)
        cur_graph_num = mask_cur.max()
        # print(cur_graph_num)
        mask1 = mask1 * (cur_graph_num+1)
        mask2 = mask2 * (cur_graph_num+2)
        # print(mask1)
        # print(mask2)
        frag_masks = (mask1+mask2).unsqueeze(0)
        # print(frag_masks)
        return t.cat([mask_cur, frag_masks],dim=1)

    def prefeaturize(self, dataset):
        self.max_atom_num = 0
        self.max_singlebond_num = 0
        for item in dataset:
            SMILES = item['SMILES']
            mol = GetMol(SMILES)
            atom_num = GetAtomNum(mol)
            self.max_atom_num = max(self.max_atom_num, atom_num)
            singlebondlist = GetSingleBonds(mol)
            self.max_singlebond_num = max(self.max_singlebond_num, len(singlebondlist))

        if self.mode == 'TRAIN':
            self.max_mask_num = self.max_atom_num * 2 + 2
        elif self.mode == 'EVAL':
            self.max_mask_num = self.max_atom_num + (self.max_atom_num + 2) * self.max_singlebond_num

        self.max_mask_num+=1

    def PadMask(self, mask):
        mask_len = mask.size()[1]
        pad_num = self.max_mask_num - mask_len
        # print(f"mask_len:{mask_len}")
        # print(f"pad_num:{pad_num}")
        # print(f"self.max_mask_num:{self.max_mask_num}")
        pad = t.ones([1,pad_num]) * -1
        pad_mask = t.cat([mask, pad],dim=1).long()
        return pad_mask







    # def prefeaturize(self, dataset):
    #     max_atom_num = 0
    #     max_
    #     for item in dataset:
    #         SMILES = item['SMILES']
    #         mol = GetMol(SMILES)


import time


class PyGFraGATFeaturizer(BasicFeaturizer):
    def __init__(self, opt, mode):
        super(PyGFraGATFeaturizer, self).__init__()
        self.opt = opt
        self.mode = mode
        self.stored_dataset = {}

    def featurize(self, item):
        # Compute tensors for molecular graph
        SMILES = item['SMILES']
        mol = GetMol(SMILES)
        Value = item['Value']
        Label = self.GetLabelFromValues(Value)
        # print(f"Label.size: {Label.size()}")

        # Calculate atom/bond features (x, edge_attr)
        if self.opt.args['FeatureCategory'] == 'BaseOH':
            x, edge_attr = GetBaseFeatureOH(mol)
        elif self.opt.args['FeatureCategory'] == 'BaseED':
            x, edge_attr = GetBaseFeatureED(mol)
        elif self.opt.args['FeatureCategory'] == 'OGB':
            x, edge_attr = GetOGBFeature(mol)
        elif self.opt.args['FeatureCategory'] == 'RichOH':
            x, edge_attr = GetRichFeatureOH(mol)
        elif self.opt.args['FeatureCategory'] == 'RichED':
            x, edge_attr = GetRichFeatureED(mol)
        else:
            raise NotImplementedError('No feature category.')

        x_orimol = t.Tensor(x)
        edge_attr_orimol = t.Tensor(edge_attr)
        # Calculate topology
        edge_index_orimol = t.Tensor(GetEdgeList(mol, bidirection=True)).long().t()

        # x: [atom_num, atom_feature_size]
        # edge_attr: [bond_num, bond_feature_size]
        # edge_index: [2, bond_num]

        atom_num = x_orimol.size()[0]
        bond_num = edge_attr_orimol.size()[0]

        # Calculate Singlebonds
        singlebond_list = GetSingleBonds(mol)
        singlebond_num = len(singlebond_list)


        # Generate Graph Tensors for Frags and JT

        if self.mode == 'TRAIN':
            # generate tensors for frags and JT
            x_frags, edge_index_frags, edge_attr_frags, mask_frags, x_JT, edge_index_JT, edge_attr_JT = \
                self.GenerateFragJTForTraining(x_orimol, edge_attr_orimol, edge_index_orimol, singlebond_list, singlebond_num)

            # merge a large graph of orimol and frags, JT are stored separately
            x_12, edge_index_12, edge_attr_12, mask_12 = \
                self.CatGraph(x_orimol, x_frags, edge_attr_orimol, edge_attr_frags, edge_index_orimol, edge_index_frags, mask_frags)

            mask_12_length = mask_12.size()[1]
            # pad the mask
            mask_12 = self.PadMask(mask_12)

            data = Data(x=x_12,
                        edge_index = edge_index_12,
                        edge_attr = edge_attr_12,
                        y = Label.t(),
                        mask_12 = mask_12,
                        x_JT = x_JT,
                        JT__JT = edge_index_JT,           # JT__JT is the edge_index of JT
                        edge_attr_JT=edge_attr_JT,
                        atom_num = atom_num,
                        bond_num = bond_num,
                        singlebond_num = singlebond_num,
                        mask_12_length = mask_12_length)
            return data

        else:
            x_all_frags, edge_index_all_frags, edge_attr_all_frags, mask_all_frags, x_all_JT, edge_index_all_JT, edge_attr_all_JT = \
                self.GenerateFragJTForEvaluation(x_orimol, edge_attr_orimol, edge_index_orimol, singlebond_list,
                                               singlebond_num)
            x_12, edge_index_12, edge_attr_12, mask_12 = \
                self.CatGraph(x_orimol, x_all_frags, edge_attr_orimol, edge_attr_all_frags, edge_index_orimol, edge_index_all_frags, mask_all_frags )
            mask_12_length = mask_12.size()[1]
            mask_12 = self.PadMask(mask_12)

            edge_index_all_JT = self.PadJTIndex(edge_index_all_JT)

            data = Data(x=x_12,
                        edge_index = edge_index_12,
                        edge_attr = edge_attr_12,
                        y = Label.t(),
                        mask_12 = mask_12,
                        x_JT = x_all_JT,
                        JT__JT = edge_index_all_JT,
                        edge_attr_JT = edge_attr_all_JT,
                        atom_num = atom_num,
                        bond_num = bond_num,
                        singlebond_num = singlebond_num,
                        mask_12_length = mask_12_length)
            self.stored_dataset.update({SMILES:data})
            return data

    def GenerateFragJTForTraining(self, x_orimol, edge_attr_orimol, edge_index_orimol,singlebond_list, singlebond_num):
        # clone tensors for the Frags Layer
        x_frags = x_orimol.clone()
        edge_attr_frags = edge_attr_orimol.clone()
        edge_index_frags = edge_index_orimol.clone()


        #
        if singlebond_num != 0:

            # randomly choose one bond from all singlebonds
            chosen_idx = random.randint(0, singlebond_num-1)
            [bond_idx, start_atom, end_atom] = singlebond_list[chosen_idx]

            # remove the chosen bond from edge_attr and edge_index:
            edge_index_frags, edge_attr_frags, removed_edge_attr = self.CutOneBond(edge_index_frags, edge_attr_frags, bond_idx, start_atom, end_atom)
            if removed_edge_attr.size()[0] != 1:
                removed_edge_attr.unsqueeze_(0)

            # generate mask to identify nodes belong to different fragments
            mask_frags = (t.ones([1,x_frags.size()[0]]) * -2).long()    # orimol_atom_num
            mask_frags = self.ComponentSearch(edge_index_frags, start_atom, mask_frags, 0)
            mask_frags = self.ComponentSearch(edge_index_frags, end_atom, mask_frags, 1)

            # if the frags cannot cover all of the nodes
            # Although the remained nodes which are not covered will not pass message to the fragments,
            # when readout, their node embeddings need to be taken into account.
            # solution 1: put the remained nodes into one of the fragments
            if -2 in mask_frags:
                mask_frags[mask_frags==-2] = 0


            # Till here, tensors for FragLayer have been done
            # x_frags: [atom_num, atom_feature_size]
            # edge_index_frags: [2, edge_num - 2]
            # edge_attr_frags: [edge_num - 2, bond_feature_size]
            # mask_frags: [1, atom_num]
            # edge_num = bond_num * 2
            # mask_frags are 0/1


            # build JT
            x_JT = t.Tensor([])
            edge_index_JT = t.Tensor([[0,1],[1,0]]).long()
            edge_attr_JT = t.cat([removed_edge_attr, removed_edge_attr],dim=0)

            # Till here, tensors for JTLayer have been done
            # x_JT: an empty tensor, waiting for the node embedding generated by FragLayer
            # edge_index_JT: [2,2], only two edges (one bond) with [0,1] and [1,0] to connect two nodes
            # edge_attr_JT: [2, bond_feature_num], edge_attr of the removed bond
            # only one graph for JT, no mask is needed

            return x_frags, edge_index_frags, edge_attr_frags, mask_frags, x_JT, edge_index_JT, edge_attr_JT

        else:
            # no bond to cut
            # when no bond to cut, the frags will be one part -- the entire molecule
            # However, if the FragsLayer contains less than 2 graph, it will be hard for the model to batch
            # so we use the pad node to generate an extra graph embedding
            # a pad node with zero feature is added, connected with no nodes
            pad_node_feature = t.zeros([1, x_frags.size()[1]])
            x_frags = t.cat([x_frags, pad_node_feature], dim = 0)  # [orimol_atom_num + 1

            # x_frags, edge_index, edge_attr not need to change
            # build mask_frags
            mask_frags = t.zeros([1, x_frags.size()[0]]).long()
            mask_frags[0,-1] = 1                                     # [0 * orimol_atom_num, 1]

            # Till here, tensors for FragLayer have been done
            # x_frags: [atom_num + 1(padnode), atom_feature_size]
            # edge_index_frags: [2, edge_num]
            # edge_attr_frags: [edge_num, bond_feature_size]
            # mask_frags: [1, atom_num + 1(padnode)], where mask_frags[-1] = 1 indicates the second graph
            # edge_num = bond_num * 2


            # build JT
            x_JT = t.Tensor([])
            edge_index_JT = t.Tensor([[1,1],[1,1]]).long()
            edge_attr_JT = t.zeros([2,edge_attr_orimol.size()[1]])

            # Till here, tensors for JTLayer have been done
            # x_JT
            # edge_index_JT: [2,2], edges connect the padnode itself, so that it will not influence the graph node's embedding
            # edge_attr_JT: [2, bond_feature_num], a pad edge with zeros attr

            return x_frags, edge_index_frags, edge_attr_frags, mask_frags, x_JT, edge_index_JT, edge_attr_JT

    def GenerateFragJTForEvaluation(self, x_orimol, edge_attr_orimol, edge_index_orimol, singlebond_list, singlebond_num):

        if singlebond_num != 0:
            # each single bong should be calculate
            x_all_frags = t.Tensor([])
            edge_attr_all_frags = t.Tensor([])
            edge_index_all_frags = t.Tensor([])
            mask_all_frags = t.Tensor([])

            x_all_JT = t.Tensor([])
            edge_index_all_JT = t.Tensor([])
            edge_attr_all_JT = t.Tensor([])
            mask_all_JT = None

            for i in range(singlebond_num):
                # copy a group of tensors

                x_frags = x_orimol.clone()
                edge_attr_frags = edge_attr_orimol.clone()
                edge_index_frags = edge_index_orimol.clone()

                # Get singlebond
                singlebond = singlebond_list[i]
                [bond_idx, start_atom, end_atom] = singlebond

                # remove the chosen bond from edge_attr and edge_index:
                edge_index_frags, edge_attr_frags, removed_edge_attr = self.CutOneBond(edge_index_frags, edge_attr_frags, bond_idx, start_atom, end_atom)
                if removed_edge_attr.size()[0] != 1:
                    removed_edge_attr.unsqueeze_(0)


                # generate mask to identify nodes belong to different fragments
                mask_frags = (t.ones([1, x_frags.size()[0]]) * -2).long()  # orimol_atom_num
                mask_frags = self.ComponentSearch(edge_index_frags, start_atom, mask_frags, 0)
                mask_frags = self.ComponentSearch(edge_index_frags, end_atom, mask_frags, 1)
                # print(f"mask_frags:{mask_frags}")

                if -2 in mask_frags:
                    mask_frags[mask_frags == -2] = 0

                # Till here, tensors for FragLayer have been done
                # x_frags: [atom_num, atom_feature_size]
                # edge_index_frags: [2, edge_num - 2]
                # edge_attr_frags: [edge_num - 2, bond_feature_size]
                # mask_frags: [1, atom_num]
                # edge_num = bond_num * 2
                # mask_frags are 0/1

                # build JT
                x_JT = t.Tensor([])
                edge_index_JT = t.Tensor([[0, 1], [1, 0]]).long()
                edge_attr_JT = t.cat([removed_edge_attr, removed_edge_attr], dim = 0)
                mask_JT = t.zeros([1,2])

                # Till here, tensors for JTLayer have been done
                # x_JT: an empty tensor, waiting for the node embedding generated by FragLayer
                # edge_index_JT: [2,2], only two edges (one bond) with [0,1] and [1,0] to connect two nodes
                # edge_attr_JT: [2, bond_feature_num], edge_attr of the removed bond
                # only one graph for JT, no mask is needed


                # Till here, Tensors for Frags and JT of the current sample have been done
                # Need to be added to the entire tensors of FragLayer and JT Layer
                x_all_frags, edge_index_all_frags, edge_attr_all_frags, mask_all_frags = \
                    self.CatGraph(x_all_frags, x_frags, edge_attr_all_frags, edge_attr_frags, edge_index_all_frags, edge_index_frags, mask1 = mask_all_frags, mask2 = mask_frags)
                # print(f"mask_all_frags:{mask_all_frags}")
                x_all_JT, edge_index_all_JT, edge_attr_all_JT, _= \
                    self.CatGraph(x_all_JT, x_JT, edge_attr_all_JT, edge_attr_JT, edge_index_all_JT, edge_index_JT, mask1 = mask_all_JT, mask2 = mask_JT)

            return x_all_frags, edge_index_all_frags, edge_attr_all_frags, mask_all_frags, x_all_JT, edge_index_all_JT, edge_attr_all_JT



        else:
            # if no bonds to cut, the generation process will be the same with Training case
            x_frags = x_orimol.clone()
            edge_attr_frags = edge_attr_orimol.clone()
            edge_index_frags = edge_index_orimol.clone()

            # no bond to cut
            # when no bond to cut, the frags will be one part -- the entire molecule
            # However, if the FragsLayer contains less than 2 graph, it will be hard for the model to batch
            # so we use the pad node to generate an extra graph embedding
            # a pad node with zero feature is added, connected with no nodes
            pad_node_feature = t.zeros([1, x_frags.size()[1]])
            x_frags = t.cat([x_frags, pad_node_feature], dim = 0)  # [orimol_atom_num + 1

            # x_frags, edge_index, edge_attr not need to change
            # build mask_frags
            mask_frags = t.zeros([1, x_frags.size()[0]]).long()
            mask_frags[0, -1] = 1  # [0 * orimol_atom_num, 1]

            # Till here, tensors for FragLayer have been done
            # x_frags: [atom_num + 1(padnode), atom_feature_size]
            # edge_index_frags: [2, edge_num]
            # edge_attr_frags: [edge_num, bond_feature_size]
            # mask_frags: [1, atom_num + 1(padnode)], where mask_frags[-1] = 1 indicates the second graph
            # edge_num = bond_num * 2

            # build JT
            x_JT = t.Tensor([])
            edge_index_JT = t.Tensor([[1, 1], [1, 1]]).long()
            edge_attr_JT = t.zeros([2, edge_attr_orimol.size()[1]])

            # Till here, tensors for JTLayer have been done
            # x_JT
            # edge_index_JT: [2,2], edges connect the padnode itself, so that it will not influence the graph node's embedding
            # edge_attr_JT: [2, bond_feature_num], a pad edge with zeros attr

            return x_frags, edge_index_frags, edge_attr_frags, mask_frags, x_JT, edge_index_JT, edge_attr_JT


    def CutOneBond(self, edge_index_origin, edge_attr_origin, bond_idx, start_atom, end_atom):
        # To remove a bond with [start_atom, end_atom] in edge_index, and pickup its corresponding edge_attr
        edge_index = edge_index_origin.t().tolist()
        edge_attr = edge_attr_origin.clone()
        assert [start_atom, end_atom] in edge_index
        assert [end_atom, start_atom] in edge_index

        # each bond_idx correspond to two edges
        bond_idx_directed = [bond_idx * 2, bond_idx * 2 + 1]
        assert edge_index[bond_idx_directed[0]] == [start_atom, end_atom]
        assert edge_index[bond_idx_directed[1]] == [end_atom, start_atom]

        # remove bond from edge_index
        edge_index.remove([start_atom, end_atom])
        edge_index.remove([end_atom, start_atom])
        edge_index = t.Tensor(edge_index).long().t()
        if edge_index.size()[0] == 0:
            edge_index = t.empty([2,0])

        # By removing one bond, the following part will move upward, so that both bond_idx_directed[0] are used
        edge_attr, removed_edge_attr1 = self.DeleteTensorRow(edge_attr, bond_idx_directed[0])
        edge_attr, removed_edge_attr2 = self.DeleteTensorRow(edge_attr, bond_idx_directed[0])
        # print(f"edge_attr.size:{edge_attr.size()}")
        # print(f"edge_index.size:{edge_index.size()}")

        assert edge_attr.size()[0] == edge_index.size()[1]
        # assert False not in (edge_attr[bond_idx_directed[0]] == edge_attr_origin[bond_idx_directed[0]+2])
        assert False not in (removed_edge_attr1 == removed_edge_attr2)
        return edge_index, edge_attr, removed_edge_attr1

    def DeleteTensorRow(self, tensor, index, dim=0):
        if dim==0:
            t1 = tensor[0:index,:]
            t2 = tensor[(index+1):,:]
            return t.cat([t1,t2],dim=0), tensor[index]
        else:
            return NotImplementedError

    def ComponentSearch(self, edge_index, root_node, mask, component_bias):
        # given a root node, find the connected part by edge_index
        # mask is a pre-constructed tensor with size [1, atom_num]
        # initially, mask are all -1
        # by two-times component search, mask will be 0 or 1

        candidate_set = []
        candidate_set.append(root_node)

        mask[0, root_node] = component_bias

        while len(candidate_set) > 0:
            node = candidate_set[0]
            candidate_set.pop(0)

            for i in range(len(edge_index[0])):
                if edge_index[0,i] == node:
                    neighbor = edge_index[1,i]
                    if mask[0, neighbor] == -2:
                        candidate_set.append(neighbor)
                        mask[0, neighbor] = component_bias

        return mask

    def CatGraph(self, x1, x2, edge_attr1, edge_attr2, edge_index1, edge_index2, mask2, mask1=None):
        atom_num1 = x1.size()[0]
        atom_num2 = x2.size()[0]
        bond_num1 = edge_attr1.size()[0]
        bond_num2 = edge_attr2.size()[0]

        x = t.cat([x1,x2],dim=0)
        edge_attr = t.cat([edge_attr1, edge_attr2],dim=0)

        edge_index2 = edge_index2 + atom_num1

        edge_index = t.cat([edge_index1, edge_index2],dim=1).long()
        assert edge_index.size()[1] == edge_attr.size()[0]

        if mask1 == None:
            mask1 = t.zeros([1,atom_num1])
            mask2 = mask2+1
        else:
            if atom_num1 != 0:
                mask2 = mask2 + (mask1[0].max() + 1)

        mask = t.cat([mask1, mask2],dim=1).long()
        if atom_num2 != 0:
            assert mask.size()[1] == (atom_num1+atom_num2)

        return x, edge_index, edge_attr, mask

    def GetLabelFromValues(self, values):
        label = []
        if self.opt.args['ClassNum'] == 1:
            if self.opt.args['TaskNum'] == 1:
                label.append(float(values))
            else:
                for v in values:
                    label.append(float(v))
            label = t.Tensor(label)
        else:
            for v in values:
                label.append(int(v))
            label = t.Tensor(label).long()
        label.unsqueeze_(-1)

        return label

    def prefeaturize(self, dataset):
        self.max_atom_num = 0
        self.max_singlebond_num = 0
        for item in dataset:
            SMILES = item['SMILES']
            mol = GetMol(SMILES)
            atom_num = GetAtomNum(mol)
            self.max_atom_num = max(self.max_atom_num, atom_num)
            singlebondlist = GetSingleBonds(mol)
            self.max_singlebond_num = max(self.max_singlebond_num, len(singlebondlist))

        if self.mode == 'TRAIN':
            # mask_12 length = atom_num + (atom_num + 1)
            self.max_mask_num = self.max_atom_num * 2 + 1
            # make sure that mask is long enough
            self.max_mask_num += 1

        elif self.mode == 'EVAL':
            self.max_mask_num = self.max_atom_num + (self.max_atom_num + 2) * self.max_singlebond_num
            self.max_JT_index_length = self.max_singlebond_num * 2
            # make sure that mask is long enough
            self.max_mask_num += 1
            self.max_JT_index_length += 1

    def PadMask(self, mask_12):
        mask_len = mask_12.size()[1]
        pad_num = self.max_mask_num - mask_len
        pad = t.ones([1,pad_num]) * -1
        pad_mask = t.cat([mask_12, pad],dim=1).long()
        return pad_mask

    def PadJTIndex(self, edge_index_all_JT):
        edge_index_len = edge_index_all_JT.size()[1]
        pad_num = self.max_JT_index_length - edge_index_len
        pad = t.ones([2,pad_num]) * -1
        pad_edge_index = t.cat([edge_index_all_JT, pad],dim=1).long()
        return pad_edge_index

class GraphormerFeaturizer(BasicFeaturizer):
    def __init__(self, max_node, multi_hop_max_dist, spatial_pos_max,opt):
        super(GraphormerFeaturizer, self).__init__()
        self.max_node = max_node
        self.multi_hop_max_dist = multi_hop_max_dist
        self.spatial_pos_max = spatial_pos_max
        self.opt = opt
        # self.offset = self.opt.args['num_offset']

    def featurize(self, item):
        '''
        original data in Graphormer
        edge_index: [2, num_edges], node index of each edge
        edge_attr: [num_edges, 3], edge feature
        x: [num_nodes, 9], node feature
        y: [num_graphs, 1], graph label
        '''
        SMILES = item['SMILES']
        mol = GetMol(SMILES)
        Value = item['Value']
        label = self.GetLabelFromValues(Value)
        # Calculate the original data
        # node feature, size:[num_nodes, 39], calculated by the feature function in ChemUtils.py
        # edge feature, size:[num_edges, 10]
        # edge index, size:[2,num_edges]
        # directed edge
        # todo(zqzhang): updated in GBv1
        if self.opt.args['FeatureCategory'] == 'BaseOH':
            x, edge_attr = GetBaseFeatureOH(mol)
        elif self.opt.args['FeatureCategory'] == 'BaseED':
            x, edge_attr = GetBaseFeatureED(mol)
        elif self.opt.args['FeatureCategory'] == 'OGB':
            x, edge_attr = GetOGBFeature(mol)
        elif self.opt.args['FeatureCategory'] == 'RichOH':
            x, edge_attr = GetRichFeatureOH(mol)
        elif self.opt.args['FeatureCategory'] == 'RichED':
            x, edge_attr = GetRichFeatureED(mol)
        else:
            raise NotImplementedError('No feature category.')
        x = t.Tensor(x).long()
        edge_attr = t.Tensor(edge_attr).long()

        edge_index = t.Tensor(GetEdgeList(mol, bidirection = True)).long().t()

        N = x.size(0)
        x = self.convert_to_single_emb(x)
        # each element of x correspond to a token,which will be embedded into a single vector by nn.Embedding.

        # node adj matrix [N, N] bool
        adj = torch.zeros([N, N], dtype=torch.bool)
        adj[edge_index[0, :], edge_index[1, :]] = True

        # edge feature here
        if len(edge_attr.size()) == 1:
            print("Call! Call! Call! Find edge_attr with size == 1!!!")
            print(f"edge_attr: {edge_attr}")
            edge_attr = edge_attr[:, None]
        # edge_attr should be [num_edge, bond_feature_size].

        attn_edge_type = torch.zeros([N, N, edge_attr.size(-1)], dtype=torch.long)
        # attn_edge_type: [node_num, node_num, bond_feature_size]
        # A tensor for what?

        # print(edge_index[0,:])
        # print(edge_index[1,:])
        # print(attn_edge_type[edge_index[0, :], edge_index[1, :]])
        # print(self.convert_to_single_emb(edge_attr) + 1)
        attn_edge_type[edge_index[0, :], edge_index[1, :]
        ] = self.convert_to_single_emb(edge_attr) + 1
        # attn_edge_type records the edge_attr with offset.
        # for each edge ( [edge_index[0,:], edge_index[1,:] ), the edge_attr is converted to a embed with offset
        # and plus 1 (why?)
        # Other [i,j], for no edge between i,j, the attr remains zeros.

        shortest_path_result, path = algos.floyd_warshall(adj.numpy())
        # Calculate and return the SPD of nodes in adj.
        # shortest_path_result is the distance of each node pairs.
        # shortest_path_result: [node_num, node_num]
        # path: [node_num, node_num]
        # for path[i,j] = k(long), it indicates that if a traveler wants to go from i to j
        # it should firstly go to k, then travel from k to j.

        max_dist = np.amax(shortest_path_result) # largest distance of SP, which indicates the N in eq.7.
        edge_input = algos.gen_edge_input(max_dist, path, attn_edge_type.numpy())
        # edge_input: [node_num, node_num, max_dist(N), edge_feat_num]
        # edge_input just stores the edge_attrs of all of the edges passing from node i to node j.
        # it is a list.

        # print(f"attn_edge_type[0,1]: {attn_edge_type[0,1,:]}")
        # print(f"attn_edge_type[1,2]: {attn_edge_type[1,2,:]}")
        # print(f"attn_edge_type[0,2]: {attn_edge_type[0,2,:]}")
        # print(f"edge_input[0,2,:]: {edge_input[0,2,:,:]}")
        # raise RuntimeError

        spatial_pos = torch.from_numpy((shortest_path_result)).long()
        # the SPD value, Phi(vi, vj)in eq.6. [node_num, node_num]
        attn_bias = torch.zeros(
            [N + 1, N + 1], dtype=torch.float)  # with graph token
        # attn_bias is initially created with [node_num+1, node_num+1]
        # i.e. A_{ij}

        in_degree = adj.long().sum(dim=1).view(-1)
        out_degree = adj.long().sum(dim=0).view(-1)
        edge_input = torch.from_numpy(edge_input).long()

        return [x,
                adj,
                attn_bias,
                attn_edge_type,
                spatial_pos,
                in_degree,
                out_degree,
                edge_input,
                label]

    def convert_to_single_emb(self, x):
        offset = self.opt.args['num_offset']
        feature_num = x.size(1) if len(x.size()) > 1 else 1
        feature_offset = 1 + \
                         torch.arange(0, feature_num * offset, offset, dtype=torch.long)
        x = x + feature_offset
        return x

    def GetLabelFromValues(self, values):
        label = []
        if self.opt.args['ClassNum'] == 1:
            if self.opt.args['TaskNum'] == 1:
                label.append(float(values))
            else:
                for v in values:
                    label.append(float(v))
            label = t.Tensor(label)
        else:
            for v in values:
                label.append(int(v))
            label = t.Tensor(label).long()
        label.unsqueeze_(-1)
        # todo(zqzhang): updated in TPv7.8
        label = label.t().contiguous()

        return label

    def GetEdgeIndex(self, mol):
        edge_list = []
        for bond in mol.GetBonds():
            i = bond.GetBeginAtomIdx()
            j = bond.GetEndAtomIdx()
            edge_list.append((i, j))
            edge_list.append((j, i))
        edge_index = np.array(edge_list, dtype = np.int64).T
        return edge_index

class AttentiveFPFeaturizer(BasicFeaturizer):
    # Featurizer to calculate the input Tensors for Attentive FP model.
    def __init__(self, atom_feature_size, bond_feature_size, max_degree):
        super(AttentiveFPFeaturizer, self).__init__()
        self.max_atom_num = 0
        self.max_bond_num = 0
        self.atom_feature_size = atom_feature_size
        self.bond_feature_size = bond_feature_size
        self.max_degree = max_degree

    def featurize(self, dataset, index, mol, value, opt):
        # unpack information from the datset.
        [entire_atom_features,
         entire_bond_features,
         entire_atom_neighbor_list,
         entire_bond_neighbor_list,
         entire_atom_mask] = dataset

        # select the query item and get the Tensors
        mol_atom_features = entire_atom_features[index]
        mol_bond_features = entire_bond_features[index]
        mol_atom_neighbor_list = entire_atom_neighbor_list[index]
        mol_bond_neighbor_list = entire_bond_neighbor_list[index]
        mol_atom_mask = entire_atom_mask[index]

        mol_atom_features = t.Tensor(mol_atom_features)
        mol_bond_features = t.Tensor(mol_bond_features)
        mol_atom_neighbor_list = t.Tensor(mol_atom_neighbor_list).long()
        mol_bond_neighbor_list = t.Tensor(mol_bond_neighbor_list).long()
        mol_atom_mask = t.Tensor(mol_atom_mask)

        # build the label tensor
        label = self.GetLabelFromValues(value)

        # sizes:
        # mol_atom_features: [max_atom_length, atom_feature_size]
        # mol_bond_features: [max_bond_length, bond_feature_size]
        # mol_atom_neighbor_list: [max_atom_length, max_degree]
        # mol_bond_neighbor_list: [max_atom_length, max_degree]
        # mol_atom_mask: [max_atom_length]

        return [mol_atom_features, mol_bond_features, mol_atom_neighbor_list, mol_bond_neighbor_list, mol_atom_mask], label

    def GetLabelFromValues(self, values):
        label = []
        if self.opt.args['ClassNum'] == 1:
            if self.opt.args['TaskNum'] == 1:
                label.append(float(values))
            else:
                for v in values:
                    label.append(float(v))
            label = t.Tensor(label)
        else:
            for v in values:
                label.append(int(v))
            label = t.Tensor(label).long()
        label.unsqueeze_(-1)

        return label

    def prefeaturize(self, dataset):
        # prefeaturize the molecule dataset to a dataset of five input tensors used for Attentive FP model.
        entire_atom_features = []
        entire_bond_features = []
        entire_atom_neighbor_list = []
        entire_bond_neighbor_list = []
        entire_atom_mask = []

        for item in dataset:
            SMILES = item['SMILES']
            mol = GetMol(SMILES)

            mol_atom_feature = np.zeros([self.max_atom_num, self.atom_feature_size])
            mol_bond_feature = np.zeros([self.max_bond_num, self.bond_feature_size])

            mol_atom_neighbor_list = np.zeros([self.max_atom_num, self.max_degree])
            mol_bond_neighbor_list = np.zeros([self.max_atom_num, self.max_degree])
            mol_atom_neighbor_list.fill(self.pad_atom_idx)
            mol_bond_neighbor_list.fill(self.pad_bond_idx)

            mol_atom_mask = np.zeros([self.max_atom_num])

            #  generate five information of a molecule.

            for atom in mol.GetAtoms():
                idx = atom.GetIdx()
                mol_atom_mask[idx] = 1.0
                atom_feature = GetAtomFeatures(atom)
                mol_atom_feature[idx] = atom_feature

                neighbors = atom.GetNeighbors()
                pointer = 0
                for neighbor in neighbors:
                    nei_idx = neighbor.GetIdx()
                    mol_atom_neighbor_list[idx][pointer] = nei_idx
                    pointer += 1

            bond_pointer = np.zeros([self.max_atom_num])
            for bond in mol.GetBonds():
                idx = bond.GetIdx()
                bond_feature = GetBondFeatures(bond)
                mol_bond_feature[idx] = bond_feature

                start_atom = bond.GetBeginAtomIdx()
                end_atom = bond.GetEndAtomIdx()

                start_atom_pointer = int(bond_pointer[start_atom])
                end_atom_pointer = int(bond_pointer[end_atom])

                mol_bond_neighbor_list[start_atom][start_atom_pointer] = idx
                mol_bond_neighbor_list[end_atom][end_atom_pointer] = idx

                bond_pointer[start_atom] += 1
                bond_pointer[end_atom] += 1

            entire_atom_features.append(mol_atom_feature)
            entire_bond_features.append(mol_bond_feature)
            entire_atom_neighbor_list.append(mol_atom_neighbor_list)
            entire_bond_neighbor_list.append(mol_bond_neighbor_list)
            entire_atom_mask.append(mol_atom_mask)

        return [entire_atom_features, entire_bond_features, entire_atom_neighbor_list, entire_bond_neighbor_list, entire_atom_mask]

    def GetPad(self, dataset):
        for item in dataset:
            smiles = item["SMILES"]
            mol = Chem.MolFromSmiles(smiles)
            total_atom_num = len(mol.GetAtoms())
            total_bond_num = len(mol.GetBonds())
            self.max_atom_num = max(self.max_atom_num, total_atom_num)
            self.max_bond_num = max(self.max_bond_num, total_bond_num)

        self.pad_atom_idx = self.max_atom_num
        self.pad_bond_idx = self.max_bond_num

        self.max_atom_num += 1
        self.max_bond_num += 1

class FraGATFeaturizer(BasicFeaturizer):
    # Featurizer to calculate input Tensors for FraGAT model
    def __init__(self, atom_feature_size, bond_feature_size, max_degree, mode):
        super(FraGATFeaturizer, self).__init__()
        self.max_atom_num = 0
        self.max_bond_num = 0
        self.atom_feature_size = atom_feature_size
        self.bond_feature_size = bond_feature_size
        self.max_degree = max_degree
        self.mode = mode

    def featurize(self, dataset, index, mol, value, opt):
        # dataset : the entire dataset after prefeturing, which consists of five lists:
        #           entire_atom_features,
        #           entire_bond_features,
        #           entire_atom_neighbor_list,
        #           entire_bond_neighbor_list,
        #           entire_atom_mask.
        #           where entire means the entire dataset.
        # index : index of the selected item. only 1 item is selected once.
        # mol : the mol object of the selected item.
        # value : the value of the seleceted item.
        # opt : the option dict.

        self.opt = opt
        # unpack information from the datset.
        [entire_atom_features,
         entire_bond_features,
         entire_atom_neighbor_list,
         entire_bond_neighbor_list,
         entire_atom_mask] = dataset

        # select the query item and get the Tensors
        mol_atom_features = entire_atom_features[index]
        mol_bond_features = entire_bond_features[index]
        mol_atom_neighbor_list = entire_atom_neighbor_list[index]
        mol_bond_neighbor_list = entire_bond_neighbor_list[index]
        mol_atom_mask = entire_atom_mask[index]

        mol_atom_features = t.Tensor(mol_atom_features)
        mol_bond_features = t.Tensor(mol_bond_features)
        mol_atom_neighbor_list = t.Tensor(mol_atom_neighbor_list).long()
        mol_bond_neighbor_list = t.Tensor(mol_bond_neighbor_list).long()
        mol_atom_mask = t.Tensor(mol_atom_mask)

        # build the label tensor
        label = self.GetLabelFromValues(value)

        # sizes:
        # mol_atom_features: [max_atom_length, atom_feature_size]
        # mol_bond_features: [max_bond_length, bond_feature_size]
        # mol_atom_neighbor_list: [max_atom_length, max_degree]
        # mol_bond_neighbor_list: [max_atom_length, max_degree]
        # mol_atom_mask: [max_atom_length]

        if self.mode == "TRAIN":
            # create the information of one molecule.
            mol_atom_neighbor_list_changed, mol_bond_neighbor_list_changed, start_atom, end_atom, bond_idx = self.CutSingleBond(
                mol, mol_atom_neighbor_list, mol_bond_neighbor_list)
            # No matter whether a bond has been cut, the structure of the return are the same.
            # However, if no bond is cut, the two neighbor_list_changed are the same as the original neighbor lists.
            # and the start_atom, end_atom, bond_idx are None.

            if bond_idx:
                # if a single bond is cut:
                mask1, mask2 = self.GetComponentMasks(start_atom, end_atom, mol_atom_neighbor_list_changed)
                mask1 = t.Tensor(mask1)
                mask2 = t.Tensor(mask2)
                mol_frag_mask1 = mask1 * mol_atom_mask
                mol_frag_mask2 = mask2 * mol_atom_mask
                # In the atom_neighbor_list, all atoms are set to be connected with the pad node.
                # so that the generated mask1 and mask2 are not correct because the pad nodes are set to 1.
                # That's why we should use mask1 * mol_atom_mask to set the pad nodes to 0.

                bond_idx = t.Tensor([bond_idx]).long()

                JT_bond_features, JT_atom_neighbor_list, JT_bond_neighbor_list, JT_mask = self.CreateJunctionTree(
                    mol_bond_features,
                    atom_neighbor_list=None,
                    bond_neighbor_list=None,
                    start_atom=start_atom,
                    end_atom=end_atom,
                    bondidx=bond_idx,
                    frag_masks=[mol_frag_mask1, mol_frag_mask2])
                # Return in such format: Origin Graph, Frags, Junction Tree
                return [mol_atom_features,
                        mol_bond_features,
                        mol_atom_neighbor_list,
                        mol_bond_neighbor_list,
                        mol_atom_mask,
                        mol_atom_neighbor_list_changed,
                        mol_bond_neighbor_list_changed,
                        mol_frag_mask1,
                        mol_frag_mask2,
                        bond_idx,
                        JT_bond_features,
                        JT_atom_neighbor_list,
                        JT_bond_neighbor_list,
                        JT_mask], label

            else:
                # No single bonds can be cut.
                # Return in such format: Origin Graph, Frags, Junction Tree
                JT_bond_features, JT_atom_neighbor_list, JT_bond_neighbor_list, JT_mask = self.CreateJunctionTree(
                    mol_bond_features, atom_neighbor_list=None, bond_neighbor_list=None, start_atom=None, end_atom=None,
                    bondidx=[], frag_masks=[])
                return [mol_atom_features,
                        mol_bond_features,
                        mol_atom_neighbor_list,
                        mol_bond_neighbor_list,
                        mol_atom_mask,
                        mol_atom_neighbor_list_changed,
                        mol_bond_neighbor_list_changed,
                        mol_atom_mask,
                        t.zeros(self.max_atom_num),
                        t.Tensor([-1]).long(),
                        JT_bond_features,
                        JT_atom_neighbor_list,
                        JT_bond_neighbor_list,
                        JT_mask], label

        elif self.mode == 'EVAL':
            # create a 'batch' of samples coming from one molecule
            extended_atom_features = t.Tensor([])
            extended_bond_features = t.Tensor([])
            extended_atom_neighbor_list = t.Tensor([]).long()
            extended_bond_neighbor_list = t.Tensor([]).long()
            extended_atom_mask = t.Tensor([])

            extended_atom_neighbor_list_changed = t.Tensor([]).long()
            extended_bond_neighbor_list_changed = t.Tensor([]).long()
            extended_frag_mask1 = t.Tensor([])
            extended_frag_mask2 = t.Tensor([])
            extended_bond_idx = t.Tensor([]).long()

            extended_JT_bond_features = t.Tensor([])
            extended_JT_atom_neighbor_list = t.Tensor([]).long()
            extended_JT_bond_neighbor_list = t.Tensor([]).long()
            extended_JT_mask = t.Tensor([])

            if opt.args['ClassNum'] == 1:
                extended_label = t.Tensor([])
            else:
                extended_label = t.Tensor([]).long()

            SingleBondList = GetSingleBonds(mol)
            if len(SingleBondList) == 0:
                # No bond is cut. Only one molecule information is used.
                # Original Graph, no change
                extended_atom_features = self.CatTensor(extended_atom_features, mol_atom_features)
                extended_bond_features = self.CatTensor(extended_bond_features, mol_bond_features)
                extended_atom_neighbor_list = self.CatTensor(extended_atom_neighbor_list, mol_atom_neighbor_list)
                extended_bond_neighbor_list = self.CatTensor(extended_bond_neighbor_list, mol_bond_neighbor_list)
                extended_atom_mask = self.CatTensor(extended_atom_mask, mol_atom_mask)

                # Frags, no change.
                extended_atom_neighbor_list_changed = self.CatTensor(extended_atom_neighbor_list_changed,
                                                                     mol_atom_neighbor_list)
                extended_bond_neighbor_list_changed = self.CatTensor(extended_bond_neighbor_list_changed,
                                                                     mol_bond_neighbor_list)
                extended_frag_mask1 = self.CatTensor(extended_frag_mask1, mol_atom_mask)
                extended_frag_mask2 = self.CatTensor(extended_frag_mask2, t.zeros(self.max_atom_num))
                extended_bond_idx = self.CatTensor(extended_bond_idx, t.Tensor([-1]).long())

                # Junction Tree
                JT_bond_features, JT_atom_neighbor_list, JT_bond_neighbor_list, JT_mask = self.CreateJunctionTree(
                    mol_bond_features, atom_neighbor_list=None, bond_neighbor_list=None, start_atom=None,
                    end_atom=None, bondidx=[], frag_masks=[])

                extended_JT_bond_features = self.CatTensor(extended_JT_bond_features, JT_bond_features)
                extended_JT_atom_neighbor_list = self.CatTensor(extended_JT_atom_neighbor_list, JT_atom_neighbor_list)
                extended_JT_bond_neighbor_list = self.CatTensor(extended_JT_bond_neighbor_list, JT_bond_neighbor_list)
                extended_JT_mask = self.CatTensor(extended_JT_mask, JT_mask)

                extended_label = self.CatTensor(extended_label, label)


            else:
                for bond in SingleBondList:
                    # Cut one bond
                    mol_atom_neighbor_list_changed, mol_bond_neighbor_list_changed, start_atom, end_atom, bond_idx \
                        = self.CutOneBond(bond, mol_atom_neighbor_list, mol_bond_neighbor_list)

                    mask1, mask2 = self.GetComponentMasks(start_atom, end_atom, mol_atom_neighbor_list_changed)
                    mask1 = t.Tensor(mask1)
                    mask2 = t.Tensor(mask2)
                    mol_frag_mask1 = mask1 * mol_atom_mask
                    mol_frag_mask2 = mask2 * mol_atom_mask
                    bond_idx = t.Tensor([bond_idx]).long()

                    JT_bond_features, JT_atom_neighbor_list, JT_bond_neighbor_list, JT_mask = self.CreateJunctionTree(
                        mol_bond_features, atom_neighbor_list=None, bond_neighbor_list=None, start_atom=start_atom,
                        end_atom=end_atom, bondidx=bond_idx, frag_masks=[mol_frag_mask1, mol_frag_mask2])

                    extended_atom_features = self.CatTensor(extended_atom_features, mol_atom_features)
                    extended_bond_features = self.CatTensor(extended_bond_features, mol_bond_features)
                    extended_atom_neighbor_list = self.CatTensor(extended_atom_neighbor_list,
                                                                 mol_atom_neighbor_list)
                    extended_bond_neighbor_list = self.CatTensor(extended_bond_neighbor_list,
                                                                 mol_bond_neighbor_list)
                    extended_atom_mask = self.CatTensor(extended_atom_mask, mol_atom_mask)

                    extended_atom_neighbor_list_changed = self.CatTensor(extended_atom_neighbor_list_changed,
                                                                         mol_atom_neighbor_list_changed)
                    extended_bond_neighbor_list_changed = self.CatTensor(extended_bond_neighbor_list_changed,
                                                                         mol_bond_neighbor_list_changed)
                    extended_frag_mask1 = self.CatTensor(extended_frag_mask1, mol_frag_mask1)
                    extended_frag_mask2 = self.CatTensor(extended_frag_mask2, mol_frag_mask2)
                    extended_bond_idx = self.CatTensor(extended_bond_idx, bond_idx)

                    extended_JT_bond_features = self.CatTensor(extended_JT_bond_features, JT_bond_features)
                    extended_JT_atom_neighbor_list = self.CatTensor(extended_JT_atom_neighbor_list,
                                                                    JT_atom_neighbor_list)
                    extended_JT_bond_neighbor_list = self.CatTensor(extended_JT_bond_neighbor_list,
                                                                    JT_bond_neighbor_list)
                    extended_JT_mask = self.CatTensor(extended_JT_mask, JT_mask)

                    extended_label = self.CatTensor(extended_label, label)

            return [extended_atom_features,
                    extended_bond_features,
                    extended_atom_neighbor_list,
                    extended_bond_neighbor_list,
                    extended_atom_mask,
                    extended_atom_neighbor_list_changed,
                    extended_bond_neighbor_list_changed,
                    extended_frag_mask1,
                    extended_frag_mask2,
                    extended_bond_idx,
                    extended_JT_bond_features,
                    extended_JT_atom_neighbor_list,
                    extended_JT_bond_neighbor_list,
                    extended_JT_mask], extended_label

        elif self.mode == 'MSN':
            # create a 'batch' of samples coming from one molecule
            extended_atom_features = t.Tensor([])
            extended_bond_features = t.Tensor([])
            extended_atom_neighbor_list = t.Tensor([]).long()
            extended_bond_neighbor_list = t.Tensor([]).long()
            extended_atom_mask = t.Tensor([])

            extended_atom_neighbor_list_changed = t.Tensor([]).long()
            extended_bond_neighbor_list_changed = t.Tensor([]).long()
            extended_frag_mask1 = t.Tensor([])
            extended_frag_mask2 = t.Tensor([])
            extended_bond_idx = t.Tensor([]).long()

            extended_JT_bond_features = t.Tensor([])
            extended_JT_atom_neighbor_list = t.Tensor([]).long()
            extended_JT_bond_neighbor_list = t.Tensor([]).long()
            extended_JT_mask = t.Tensor([])

            if opt.args['ClassNum'] == 1:
                extended_label = t.Tensor([])
            else:
                extended_label = t.Tensor([]).long()

            SingleBondList = GetSingleBonds(mol)
            if len(SingleBondList) == 0:
                # No bond is cut. Only one molecule information is used.
                # Original Graph, no change
                extended_atom_features = self.CatTensor(extended_atom_features, mol_atom_features)
                extended_bond_features = self.CatTensor(extended_bond_features, mol_bond_features)
                extended_atom_neighbor_list = self.CatTensor(extended_atom_neighbor_list, mol_atom_neighbor_list)
                extended_bond_neighbor_list = self.CatTensor(extended_bond_neighbor_list, mol_bond_neighbor_list)
                extended_atom_mask = self.CatTensor(extended_atom_mask, mol_atom_mask)

                # Frags, no change.
                extended_atom_neighbor_list_changed = self.CatTensor(extended_atom_neighbor_list_changed,
                                                                     mol_atom_neighbor_list)
                extended_bond_neighbor_list_changed = self.CatTensor(extended_bond_neighbor_list_changed,
                                                                     mol_bond_neighbor_list)
                extended_frag_mask1 = self.CatTensor(extended_frag_mask1, mol_atom_mask)
                extended_frag_mask2 = self.CatTensor(extended_frag_mask2, t.zeros(self.max_atom_num))
                extended_bond_idx = self.CatTensor(extended_bond_idx, t.Tensor([-1]).long())

                # Junction Tree
                JT_bond_features, JT_atom_neighbor_list, JT_bond_neighbor_list, JT_mask = self.CreateJunctionTree(
                    mol_bond_features, atom_neighbor_list=None, bond_neighbor_list=None, start_atom=None,
                    end_atom=None, bondidx=[], frag_masks=[])

                extended_JT_bond_features = self.CatTensor(extended_JT_bond_features, JT_bond_features)
                extended_JT_atom_neighbor_list = self.CatTensor(extended_JT_atom_neighbor_list, JT_atom_neighbor_list)
                extended_JT_bond_neighbor_list = self.CatTensor(extended_JT_bond_neighbor_list, JT_bond_neighbor_list)
                extended_JT_mask = self.CatTensor(extended_JT_mask, JT_mask)

                extended_label = self.CatTensor(extended_label, label)


            else:
                for bond in SingleBondList:
                    # Cut one bond
                    mol_atom_neighbor_list_changed, mol_bond_neighbor_list_changed, start_atom, end_atom, bond_idx \
                        = self.CutOneBond(bond, mol_atom_neighbor_list, mol_bond_neighbor_list)

                    mask1, mask2 = self.GetComponentMasks(start_atom, end_atom, mol_atom_neighbor_list_changed)
                    mask1 = t.Tensor(mask1)
                    mask2 = t.Tensor(mask2)
                    mol_frag_mask1 = mask1 * mol_atom_mask
                    mol_frag_mask2 = mask2 * mol_atom_mask
                    bond_idx = t.Tensor([bond_idx]).long()

                    JT_bond_features, JT_atom_neighbor_list, JT_bond_neighbor_list, JT_mask = self.CreateJunctionTree(
                        mol_bond_features, atom_neighbor_list=None, bond_neighbor_list=None, start_atom=start_atom,
                        end_atom=end_atom, bondidx=bond_idx, frag_masks=[mol_frag_mask1, mol_frag_mask2])

                    extended_atom_features = self.CatTensor(extended_atom_features, mol_atom_features)
                    extended_bond_features = self.CatTensor(extended_bond_features, mol_bond_features)
                    extended_atom_neighbor_list = self.CatTensor(extended_atom_neighbor_list,
                                                                 mol_atom_neighbor_list)
                    extended_bond_neighbor_list = self.CatTensor(extended_bond_neighbor_list,
                                                                 mol_bond_neighbor_list)
                    extended_atom_mask = self.CatTensor(extended_atom_mask, mol_atom_mask)

                    extended_atom_neighbor_list_changed = self.CatTensor(extended_atom_neighbor_list_changed,
                                                                         mol_atom_neighbor_list_changed)
                    extended_bond_neighbor_list_changed = self.CatTensor(extended_bond_neighbor_list_changed,
                                                                         mol_bond_neighbor_list_changed)
                    extended_frag_mask1 = self.CatTensor(extended_frag_mask1, mol_frag_mask1)
                    extended_frag_mask2 = self.CatTensor(extended_frag_mask2, mol_frag_mask2)
                    extended_bond_idx = self.CatTensor(extended_bond_idx, bond_idx)

                    extended_JT_bond_features = self.CatTensor(extended_JT_bond_features, JT_bond_features)
                    extended_JT_atom_neighbor_list = self.CatTensor(extended_JT_atom_neighbor_list,
                                                                    JT_atom_neighbor_list)
                    extended_JT_bond_neighbor_list = self.CatTensor(extended_JT_bond_neighbor_list,
                                                                    JT_bond_neighbor_list)
                    extended_JT_mask = self.CatTensor(extended_JT_mask, JT_mask)

                    extended_label = self.CatTensor(extended_label, label)

            MolBatchNum = t.Tensor([len(SingleBondList)]).long()
            #print(MolBatchNum)
            #print(extended_atom_features.size())
            assert len(SingleBondList) == extended_atom_features.size()[0]

            return [extended_atom_features,
                    extended_bond_features,
                    extended_atom_neighbor_list,
                    extended_bond_neighbor_list,
                    extended_atom_mask,
                    extended_atom_neighbor_list_changed,
                    extended_bond_neighbor_list_changed,
                    extended_frag_mask1,
                    extended_frag_mask2,
                    extended_bond_idx,
                    extended_JT_bond_features,
                    extended_JT_atom_neighbor_list,
                    extended_JT_bond_neighbor_list,
                    extended_JT_mask,
                    MolBatchNum], extended_label
        else:
            print("Wrong mode.")
            raise RuntimeError

    def GetLabelFromValues(self, values):
        label = []
        if self.opt.args['ClassNum'] == 1:
            if self.opt.args['TaskNum'] == 1:
                label.append(float(values))
            else:
                for v in values:
                    label.append(float(v))
            label = t.Tensor(label)
        else:
            for v in values:
                label.append(int(v))
            label = t.Tensor(label).long()
        label.unsqueeze_(-1)

        return label

    def CreateJunctionTree(self, mol_bond_features, atom_neighbor_list, bond_neighbor_list, start_atom, end_atom, bondidx, frag_masks):
        # For simple, in this version, we only consider that 0 or 1 bond is cut.
        # The case that multiple bonds are cut will be considered in the furture version.
        pad_bond_feature = t.zeros(1, self.bond_feature_size)        # [1, bond_feature_size]
        cut_bonds_num = len(bondidx)
        if cut_bonds_num == 0:
            JT_bond_feature = t.cat([pad_bond_feature, pad_bond_feature])      # [2, bond_feature_size]. max_bond_num = 2

            JT_atom_neighbor_list = np.zeros([3, self.max_degree])                # max_frag_num = 2, max_atom_num = 3, for 1 pad node.
            JT_atom_neighbor_list.fill(2)
            JT_bond_neighbor_list = np.zeros([3, self.max_degree])
            JT_bond_neighbor_list.fill(1)

            JT_atom_neighbor_list = t.Tensor(JT_atom_neighbor_list).long()
            JT_bond_neighbor_list = t.Tensor(JT_bond_neighbor_list).long()

            JT_mask = t.Tensor([1.0,0.0,0.0])

        elif cut_bonds_num == 1:
            JT_bond_feature = t.cat([mol_bond_features[bondidx], pad_bond_feature])        # [2, bond_feature_size]
            JT_atom_neighbor_list = np.zeros([3, self.max_degree])  # max_frag_num = 2, max_atom_num = 3, for 1 pad node.
            JT_atom_neighbor_list.fill(2)
            JT_bond_neighbor_list = np.zeros([3, self.max_degree])
            JT_bond_neighbor_list.fill(1)

            JT_atom_neighbor_list[0,0] = 1
            JT_atom_neighbor_list[1,0] = 0
            JT_bond_neighbor_list[0,0] = 0
            JT_bond_neighbor_list[1,0] = 0

            JT_atom_neighbor_list = t.Tensor(JT_atom_neighbor_list).long()
            JT_bond_neighbor_list = t.Tensor(JT_bond_neighbor_list).long()

            JT_mask = t.Tensor([1.0,1.0,0.0])
        # sizes:
        # mol_atom_features: [max_atom_length, atom_feature_size]
        # mol_bond_features: [max_bond_length, bond_feature_size]
        # mol_atom_neighbor_list: [max_atom_length, max_degree]
        # mol_bond_neighbor_list: [max_atom_length, max_degree]
        # mol_atom_mask: [max_atom_length]
        return JT_bond_feature, JT_atom_neighbor_list, JT_bond_neighbor_list, JT_mask

    def GetPad(self, dataset):
        # To calculate the index of the pad node
        # this function must be run before prefeaturize function.
        for item in dataset:
            smiles = item["SMILES"]
            mol = GetMol(smiles)
            total_atom_num = len(mol.GetAtoms())
            total_bond_num = len(mol.GetBonds())
            self.max_atom_num = max(self.max_atom_num, total_atom_num)
            self.max_bond_num = max(self.max_bond_num, total_bond_num)

        self.pad_atom_idx = self.max_atom_num
        self.pad_bond_idx = self.max_bond_num

        self.max_atom_num += 1
        self.max_bond_num += 1
        # The index of the pad atom/bond is the exact max atom/bond num
        # and after padding ,the max_atom/bond_num += 1
        # e.g., the exact max atom num is 100, which means No.0~99 are true atoms, and No.100 is the pad.
        # and then, the max_atom_num after padding is 101.

    def CatTensor(self, stacked_tensor, new_tensor):
        extended_new_tensor = new_tensor.unsqueeze(dim=0)
        new_stacked_tensor = t.cat([stacked_tensor, extended_new_tensor], dim=0)
        return new_stacked_tensor

    def CutOneBond(self, bond, mol_atom_neighbor_list, mol_bond_neighbor_list):
        # for eval, cut one given bond
        _mol_atom_neighbor_list = mol_atom_neighbor_list.clone()
        _mol_bond_neighbor_list = mol_bond_neighbor_list.clone()
        # insulate.
        [bond_idx, start_atom_idx, end_atom_idx] = bond
        assert end_atom_idx in _mol_atom_neighbor_list[start_atom_idx]
        assert start_atom_idx in _mol_atom_neighbor_list[end_atom_idx]

        loc = _mol_atom_neighbor_list[start_atom_idx].tolist().index(end_atom_idx)
        _mol_atom_neighbor_list[start_atom_idx][loc] = self.pad_atom_idx
        loc = _mol_atom_neighbor_list[end_atom_idx].tolist().index(start_atom_idx)
        _mol_atom_neighbor_list[end_atom_idx][loc] = self.pad_atom_idx

        loc = _mol_bond_neighbor_list[start_atom_idx].tolist().index(bond_idx)
        _mol_bond_neighbor_list[start_atom_idx][loc] = self.pad_bond_idx
        loc = _mol_bond_neighbor_list[end_atom_idx].tolist().index(bond_idx)
        _mol_bond_neighbor_list[end_atom_idx][loc] = self.pad_bond_idx

        return _mol_atom_neighbor_list, _mol_bond_neighbor_list, start_atom_idx, end_atom_idx, bond_idx

    def CutSingleBond(self, mol, mol_atom_neighbor_list, mol_bond_neighbor_list):
        # for train
        # This function will calculate the SingleBondList and tries to cut a random one.
        # if len(SingleBondList) > 0, one single bond will be cut. The two neighbor lists will be modified.
        # the return is [mol_atom_neighbor_list_changed, mol_bond_neighbor_list_changed, start_atom, end_atom, bond_idx]
        # and if len(SingleBondList) == 0, no single bond will be cut. The two neighbor lists will not be modified.
        # the return is [mol_atom_neighbor_list, mol_bond_neighbor_list, None, None, None]
        # This function is compatible with the molecules that cannot be cut.

        # mol_atom_neighbor_list and mol_bond_neighbor_list are original neighbor lists that transmit to this function.
        # However, using neighbor_list[x,x] = xxx will exactly change the value of the original neighbor lists.
        # so, the Tensors should be cloned first, to make sure that the Tensors outside of this function will not be changed.

        _mol_atom_neighbor_list = mol_atom_neighbor_list.clone()
        _mol_bond_neighbor_list = mol_bond_neighbor_list.clone()
        # insulate.

        SingleBondList = GetSingleBonds(mol)
        if len(SingleBondList) > 0:
            # Choose one bond to cut.
            random.shuffle(SingleBondList)
            [bond_idx, start_atom_idx, end_atom_idx] = SingleBondList[0]
            assert end_atom_idx in _mol_atom_neighbor_list[start_atom_idx]
            assert start_atom_idx in _mol_atom_neighbor_list[end_atom_idx]

            # modify the two neighbor lists based on the chosen bond.
            loc = _mol_atom_neighbor_list[start_atom_idx].tolist().index(end_atom_idx)
            _mol_atom_neighbor_list[start_atom_idx][loc] = self.pad_atom_idx
            loc = _mol_atom_neighbor_list[end_atom_idx].tolist().index(start_atom_idx)
            _mol_atom_neighbor_list[end_atom_idx][loc] = self.pad_atom_idx

            loc = _mol_bond_neighbor_list[start_atom_idx].tolist().index(bond_idx)
            _mol_bond_neighbor_list[start_atom_idx][loc] = self.pad_bond_idx
            loc = _mol_bond_neighbor_list[end_atom_idx].tolist().index(bond_idx)
            _mol_bond_neighbor_list[end_atom_idx][loc] = self.pad_bond_idx

            return _mol_atom_neighbor_list, _mol_bond_neighbor_list, start_atom_idx, end_atom_idx, bond_idx
        else:
            # no bond can be cut. _nei_list is same as the original one
            return _mol_atom_neighbor_list, _mol_bond_neighbor_list, None, None, None

    def GetComponentMasks(self, root_node1, root_node2, mol_atom_neighbor_list):
        mask1 = self.ComponentSearch(mol_atom_neighbor_list, self.max_atom_num, root_node1)
        mask2 = self.ComponentSearch(mol_atom_neighbor_list, self.max_atom_num, root_node2)
        assert len(mask1) == len(mask2)
        return mask1, mask2

    def ComponentSearch(self, mol_atom_neighbor_list, max_atom_num, root_node):
        candidate_set = []
        mask = np.zeros([max_atom_num])
        mask[root_node] = 1
        candidate_set.append(root_node)

        while len(candidate_set) > 0:
            node = candidate_set[0]
            candidate_set.pop(0)

            neighbors = mol_atom_neighbor_list[node]
            for nei in neighbors:
                if mask[nei] == 0:
                    candidate_set.append(nei)
                    mask[nei] = 1

        assert len(candidate_set) == 0
        return mask

    def prefeaturize(self, dataset):
        # The five input tensors of the original graph:
        # entire_atom_features, entire_bond_features, entire_atom_neighbor_list, entire_bond_neighbor_list and entire_atom_mask
        # can be prefeaturized when building the dataset to accelerate the training progress.
        # But since the cutting step is randomly selected during training, the information of frags and JTs cannot be prefeaturized.
        # So they will be calculated in the 'featurize' function.
        entire_atom_features = []
        entire_bond_features = []
        entire_atom_neighbor_list = []
        entire_bond_neighbor_list = []
        entire_atom_mask = []

        for item in dataset:
            SMILES = item['SMILES']
            mol = GetMol(SMILES)

            mol_atom_feature = np.zeros([self.max_atom_num, self.atom_feature_size])
            mol_bond_feature = np.zeros([self.max_bond_num, self.bond_feature_size])

            mol_atom_neighbor_list = np.zeros([self.max_atom_num, self.max_degree])
            mol_bond_neighbor_list = np.zeros([self.max_atom_num, self.max_degree])
            mol_atom_neighbor_list.fill(self.pad_atom_idx)
            mol_bond_neighbor_list.fill(self.pad_bond_idx)

            mol_atom_mask = np.zeros([self.max_atom_num])

            #  generate five information Tensors of a molecule.

            for atom in mol.GetAtoms():
                idx = atom.GetIdx()
                mol_atom_mask[idx] = 1.0
                atom_feature = GetAtomFeatures(atom)
                mol_atom_feature[idx] = atom_feature

                neighbors = atom.GetNeighbors()
                pointer = 0
                for neighbor in neighbors:
                    nei_idx = neighbor.GetIdx()
                    mol_atom_neighbor_list[idx][pointer] = nei_idx
                    pointer += 1

            bond_pointer = np.zeros([self.max_atom_num])
            for bond in mol.GetBonds():
                idx = bond.GetIdx()
                bond_feature = GetBondFeatures(bond)
                mol_bond_feature[idx] = bond_feature

                start_atom = bond.GetBeginAtomIdx()
                end_atom = bond.GetEndAtomIdx()

                start_atom_pointer = int(bond_pointer[start_atom])
                end_atom_pointer = int(bond_pointer[end_atom])

                mol_bond_neighbor_list[start_atom][start_atom_pointer] = idx
                mol_bond_neighbor_list[end_atom][end_atom_pointer] = idx

                bond_pointer[start_atom] += 1
                bond_pointer[end_atom] += 1

            entire_atom_features.append(mol_atom_feature)
            entire_bond_features.append(mol_bond_feature)
            entire_atom_neighbor_list.append(mol_atom_neighbor_list)
            entire_bond_neighbor_list.append(mol_bond_neighbor_list)
            entire_atom_mask.append(mol_atom_mask)

        return [entire_atom_features, entire_bond_features, entire_atom_neighbor_list, entire_bond_neighbor_list, entire_atom_mask]

class CMPNNFeaturizer(BasicFeaturizer):
    # Featurizer to calculate Input Tensors of the CMPNN model
    def __init__(self, opt):
        super(CMPNNFeaturizer, self).__init__()
        self.opt = opt

    def featurize(self, item):
        SMILES = item['SMILES']
        Value = item['Value']
        Label = self.GetLabelFromValues(Value)

        return SMILES, Label

    def GetLabelFromValues(self, values):
        label = []
        if self.opt.args['ClassNum'] == 1:
            if self.opt.args['TaskNum'] == 1:
                label.append(float(values))
            else:
                for v in values:
                    label.append(float(v))
            label = t.Tensor(label)
        else:
            for v in values:
                label.append(int(v))
            label = t.Tensor(label).long()
        label.unsqueeze_(-1)

        return label

# todo(zqzhang): updated in TPv7
class PretrainFeatureFeaturizer(BasicFeaturizer):
    def __init__(self, opt):
        super(PretrainFeatureFeaturizer, self).__init__()
        self.opt = opt

    def featurize(self, item):
        Feature = item['Feature']
        Feature = t.Tensor(Feature)
        Value = item['Value']

        if (self.opt.args['ExpName'] == 'Tox21') or (self.opt.args['ExpName'] == 'Toxcast'):
            for i in range(len(Value)):
                value = Value[i]
                if np.isnan(value):
                    Value[i] = -1

        Label = self.GetLabelFromValues(Value)
        return Feature, Label


    def GetLabelFromValues(self, values):
        label = []
        if self.opt.args['ClassNum'] == 1:
            if self.opt.args['TaskNum'] == 1:
                label.append(float(values))
            else:
                for v in values:
                    label.append(float(v))
            label = t.Tensor(label)
        else:
            for v in values:
                label.append(int(v))
            label = t.Tensor(label).long()
        label.unsqueeze_(-1)

        return label

# todo(zqzhang): updated in TPv7
class RawFeatureFeaturizer(BasicFeaturizer):
    def __init__(self, opt):
        super(RawFeatureFeaturizer, self).__init__()
        self.opt = opt

    def featurize(self, item):
        Feature = item['Feature']
        Feature = t.Tensor(Feature)
        Value = item['Value']

        # Label = self.GetLabelFromValues(Value)
        # print(f"Value in featurizer: {Value}")
        if self.opt.args['ClassNum'] != 1:
            Label = t.Tensor([Value]).long()
        else:
            Label = t.Tensor([Value])
        # print(f"Label in featurizer: {Label}")
        Label = Label.unsqueeze_(-1)
        # print(f"Label after featurizer: {Label}")
        return Feature, Label

    def GetLabelFromValues(self, values):
        label = []
        if self.opt.args['ClassNum'] == 1:
            if self.opt.args['TaskNum'] == 1:
                label.append(float(values))
            else:
                for v in values:
                    label.append(float(v))
            label = t.Tensor(label)
        else:
            for v in values:
                label.append(int(v))
            label = t.Tensor(label).long()
        label.unsqueeze_(-1)

        return label



#########################################################################
# Test Codes
#########################################################################
if __name__ == '__main__':
    SMILES1 = 'Cc1cc(C)c(C)cc1C'
    SMILES2 = 'c1ccccc1'
    SMILES3 = 'Cc1cc(C)c(C)cc1C'

    Value = '1'
    dataset = [{'SMILES': SMILES1, 'Value': Value},{'SMILES':SMILES2, 'Value':Value}, {'SMILES': SMILES3, 'Value': Value}]
    item1 = dataset[0]
    item2 = dataset[1]
    item3 = dataset[2]
    mol1 = GetMol(SMILES1)
    DrawMolGraph(mol1, './', '1')
    mol2 = GetMol(SMILES2)
    DrawMolGraph(mol2, './','2')
    mol3 = GetMol(SMILES3)
    DrawMolGraph(mol3, './', '3')

    class OPT(object):
        def __init__(self):
            super(OPT,self).__init__()
            self.args = {'ClassNum': 1,
                         'TaskNum': 1,
                         'FeatureCategory': 'BaseOH'}

    opt = OPT()

    # from TrainingFramework.Dataset import PyGMolDataset
    # Set Featurizer
    # featurizer = PyGFraGATFeaturizer(opt,'TRAIN')
    featurizer = PyGFraGATFeaturizer(opt,'EVAL')
    featurizer.prefeaturize(dataset)
    print(f"featurizing data1")
    data1 = featurizer.featurize(item1)
    print(f"featurizing data2")
    data2 = featurizer.featurize(item2)
    print(f"featurizing data3")
    data3 = featurizer.featurize(item3)
    data1.__setattr__("idx", 1)
    data2.__setattr__('idx', 2)
    data3.__setattr__('idx', 3)

    print(f"data: {data1}")
    # print(f"data1.edge_attr: {data1.edge_attr}")


    print(f"data: {data2}")
    print(f"data: {data3}")


    dataset = [data1, data2, data3]
    #
    # ########################
    # # Try PyG Dataloader
    from torch_geometric.loader import DataLoader
    #
    # def collate_first_dim(batch):
    #     all_batch_tensor, labels = map(list, zip(*batch))
    #     list_res_each_position = [[] for i in range(16)]
    #     len_each_position = [[] for i in range(16)]
    #     for one_16 in all_batch_tensor:
    #         for index, one_tensor in enumerate(one_16):
    #             list_res_each_position[index].append(one_tensor)
    #             len_each_position[index].append(len(one_tensor))
    #     len_each_position = len_each_position[0]
    #     res = []
    #     for item_list in list_res_each_position:
    #         one_res = t.stack(item_list, dim = 0)
    #         res.append(one_res)
    #     labels = t.tensor(labels).long()
    #     return res, labels, len_each_position
    #
    loader = DataLoader(dataset, batch_size = 3, shuffle = True)

    for batch in loader:
        print(batch)
        print(batch.batch)
        print(batch.singlebonds)
        print(batch.singlebond_num)
        print(batch.edge_index)
        print(batch.edge_attr)
        print(batch.ptr)

        x_batch = batch.x
        edge_index_batch = batch.edge_index
        edge_attr_batch = batch.edge_attr

        new_data = Data(x = x_batch, edge_index = edge_index_batch, edge_attr = edge_attr_batch)
        print(new_data)



